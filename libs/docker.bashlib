#!/bin/bash

#############################################################################
#
#   docker.bashlib; basic functions to get info about docker containers
#
#############################################################################
function docker.UID()
{
    local -r user_name="${1:-docker}"
    local -r default_uid=${2:-999}

    lib.lookupId "$user_name" 'passwd' "$default_uid"
}
export -f docker.UID

#----------------------------------------------------------------------------------------------
function docker.GID()
{
    local -r group_name="${1:-docker}"
    local -r default_gid=${2:-999}

    lib.lookupId "$group_name" 'group' "$default_gid"
}
export -f docker.GID

#----------------------------------------------------------------------------------------------
function docker.containerVersion()
{
    local -r line=${1:?}
    local -r json=${2:?}

    local -r image="$(sed -E 's|\s+image:\s+(.+)$|\1|' <<< "$line")"
    while read -r srvc; do
        local service=$(jq ".services.$srvc" <<< "$json")
        [ $(jq -r '.image' <<< "$service") = "$image" ] || continue

        local container=$(jq -r '.container_name' <<< "$service")
        local version=$(docker inspect "$container" | jq -r '.[].Config.Labels."container.fingerprint"')
        [ "$version" != 'null' ] || break
        local newimage="$(docker inspect "$container" | jq -r '.[].Config.Image')"
        newimage="${newimage%:*}:$version"

        echo -n '{"orgline":"'${line}'","orgimage":"'$(eval echo $image)'",'
        echo -n '"version":"'$version'",'
        echo '"newline":"'${line%\${CONTAINER_TAG*}'${CONTAINER_TAG:-'$version'}","newimage":"'$newimage'"}'
        break

    done < <(jq -r '.services|keys[]' <<< "$json")
}
export -f docker.containerVersion

#----------------------------------------------------------------------------------------------
function docker.networks()
{
    local -a networks=( $( docker network ls | grep 'default' | awk "{ print \$1 }" ) )
    docker network inspect "${networks[@]}" \
    | jq -r ".[].Containers|.[]|[.IPv4Address + \" : \" + .Name]|.[]" \
    | sort -t "." -k 4g
}
export -f docker.networks

#----------------------------------------------------------------------------------------------
function docker.rmOldContainers()
{
    local -a collection
    local -i blocksUsedBefore="$(df /var/lib/docker/volumes | awk '{if (NR==2) {print $3}}')"

    # remove all containers which are stopped along with their associated volumes
    collection=()
    collection=( $(docker ps --all --quiet --filter "status=exited" --filter "status=dead" --format "{{.Names}}") )
    if [ ${#collection[@]} -gt 0 ]; then
        printf 'Deleting %d exited containers\n' ${#collection[@]}
        docker rm --volumes "${collection[@]}"  ||:
    fi

    # remove any 'dangling' images  (those with <none> in name)
    collection=( $(docker images --quiet --filter "dangling=true") )
    if [ ${#collection[@]} -gt 0 ]; then
        printf 'Deleting %d dangling images\n' ${#collection[@]}
        docker rmi "${collection[@]}" ||:
    fi

    # get list of volumes associated with running containers
    collection=()
    for volume in $(docker ps --all --quiet); do
        collection+=( $(docker inspect "$volume" | jq -r '.[] | .Mounts | .[] | .Name | select(.)') )
    done
    [ ${#collection[*]} -eq 0 ] || printf 'Detected %d mounts associated with running containers\n' ${#collection[*]}
    if [ ${#collection[@]} -gt 0 ]; then
        local volumes="$( printf '%s\n' "${collection[@]}" )"

        # remove directories associated with unused volumes
        local -i deletions=0
        for dir in $(sudo find '/var/lib/docker/volumes/' -mindepth 1 -maxdepth 1 -type d); do
            (grep "$dir" <<< "$volumes") && continue
            sudo rm -rf "$dir"
            (( deletions++ )) ||:
        done
        [ $deletions -eq 0 ] || printf 'Deleted %d directories associated with volumes no longer in use\n' $deletions
    fi

    local -i blocksUsedAfter="$(df /var/lib/docker/volumes | awk '{if (NR==2) {print $3}}')"
    local -i recovered=$(( blocksUsedBefore - blocksUsedAfter ))
    [ $recovered -eq 0 ] || printf 'Recovered %d kb\n' $recovered
    echo
}
export -f docker.rmOldContainers

#----------------------------------------------------------------------------------------------
function docker.services()
{
    local -r dc_yaml="${1:?'no docker-compose.yml specified'}"

    docker.yamlToJson "$dc_yaml" | jq -r '.services|keys[]?'
}
export -f docker.services

#----------------------------------------------------------------------------------------------
function docker.showProcessReport()
{
    local -r opts=${1:-}

    local fmt='table {{.Names}}\t{{.ID}}\t{{.Size}}\t{{.Status}}\t{{.RunningFor}}'
    [ "$opts" ] || fmt="$fmt"'\t{{.Ports}}'

    # show process report
    echo
    mapfile -t containers < <(docker ps --format "$fmt")
    echo -e "\e[97m${containers[0]}\e[0m"
    unset containers[0]
    printf '%s\n' "${containers[@]}" | sort
}
export -f docker.showProcessReport

#----------------------------------------------------------------------------------------------
function docker.yamlToJson()
{
    local -r yamlFile=${1:?}
    local -ar YAML_TO_JSON=( 'python' '-c' 'import sys, yaml, json; json.dump(yaml.safe_load(sys.stdin), sys.stdout, indent=4)' )

    if [ -e "$yamlFile"  ]; then
        "${YAML_TO_JSON[@]}" < "$yamlFile"

    elif [[ "$yamlFile" == http* ]]; then
        "${YAML_TO_JSON[@]}" <<< "$(curl --insecure --silent --request GET "$yamlFile")"

    else
        "${YAML_TO_JSON[@]}" <<< "$yamlFile"
    fi
}
export -f docker.yamlToJson
#----------------------------------------------------------------------------------------------
