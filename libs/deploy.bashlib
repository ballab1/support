#!/bin/bash

#----------------------------------------------------------------------------------------------
#
#   deploy.bashlib; basic functions to run a cluster docker environment
#

#----------------------------------------------------------------------------------------------
# initialize global variables
function deploy.__initGlobals()
{
    local -r base_dir="${1:?}"
    local -r container_tag="${2:-}"

    export START_TIME="$(date)"

    [ -e "${base_dir}/.git" ] || trap.die "invalid base directory specified"

    # setup environment
    export CONFIG_DIR="${base_dir}"
    readonly CONFIG_DIR

    export WORKSPACE_DIR="$(deploy.workspace "$base_dir")"
    readonly WORKSPACE_DIR


    # verify our basic setup is good
    [ -f "${CONFIG_DIR}/container.os" ] || trap.die "missing 'container.os' file"
    export CONTAINER_OS="$(< "${CONFIG_DIR}/container.os")"
    readonly CONTAINER_OS

    # verify docker-compose.yml in 'config' dir
    export CONFIG_YAML="${CONFIG_DIR}/docker-compose.yml"
    readonly CONFIG_YAML
    [ -e "$CONFIG_YAML" ] || trap.die "Invalid configuration - no $CONFIG_YAML"


    local -i file_count=0
    if [ -d "$WORKSPACE_DIR" ]; then
        local -a files
        mapfile -t files < <(sudo find "$WORKSPACE_DIR" -maxdepth 1 -type f ! -name '*.log' ||:)
        file_count="${#files[*]}"
    fi
    [ "$file_count" -gt 0 ] || deploy.showInitializationBanner


    export VERSIONS_INFO="${CONFIG_DIR}/.versions"
    readonly VERSIONS_INFO

    export LOG_DIR="${base_dir}/logs"
    readonly LOG_DIR

    export SECRETS_DIR="${WORKSPACE_DIR}/.secrets"
    readonly SECRETS_DIR

    export CONTAINER_TAG="$(deploy.containerTag "$container_tag")"

    export CFG_USER
    : ${CFG_USER:=$(git.user)}
    : ${CFG_USER:=${USERNAME:-}}
    : ${CFG_USER:=${USER:-}}
    CFG_USER="${CFG_USER%@*}"
    readonly CFG_USER

    export CFG_NAME="${CFG_NAME:-$(git.userName)}"
    readonly CFG_NAME

    export CFG_EMAIL="${CFG_EMAIL:-$(git.userEmail)}"
    readonly CFG_EMAIL


    # enable container logging during startup
    : ${DEBUG_TRACE:=0}
    export DEBUG_TRACE=$(( ++DEBUG_TRACE )) ||:


    # import our setup configuration
    lib.exportFileVars "${CONFIG_DIR}/setup.cfg"

    # verify we have the mandatory env variables defied
    : ${HOST_IP:?"HOST_IP has not been configured. Please update '$setup_config'"}
    : ${HOST_NAME:?"HOST_NAME has not been configured. Please update '$setup_config'"}

    # verify that all our environment variables have been set
    (eval echo printf '%s %s\n' $(grep ':?}' docker-compose.yml) &>/dev/null) || trap.die 'undefined environment variables'
}

#----------------------------------------------------------------------------------------------
# remove any running containers then delete workspace directory
function deploy.clean()
{
    # check networks to determine if there are running containers
    local network="$(basename "${WORKSPACE_DIR}")_default"
    network="${network//./}"
    local -i networks=$(docker network ls | grep -cs "$network")
    if [ "$networks" -gt 0 ]; then
        # need docker=compose.yml to stope/remove running containers
        mkdir -p "$WORKSPACE_DIR" ||:
        local -r dc_yaml="${WORKSPACE_DIR}/docker-compose.yml"
        sudo cp "$CONFIG_YAML" "$dc_yaml"
        sudo  sed -Ei -e 's|(:\?})|:-}|g' "$dc_yaml"

        term.log 'INFO: bringing down containers to allow "workspace" to be cleaned5\n' 'lt_magenta'
        term.log '$docker-compose down\n' 'grey'
        docker-compose --file "$dc_yaml" down ||:
    fi

    # remove workspace folder
    term.log "\$rm -rf $WORKSPACE_DIR"'\n' 'grey'
    sudo rm -rf "$WORKSPACE_DIR"
}

#----------------------------------------------------------------------------------------------
function deploy.containerTag()
{
    local -r container_tag=${1:-}

    case $(git.branch) in
        dev)                       echo 'dev';;
        master|integration)        echo "$container_tag";;
        *)                         echo 'latest';;
    esac
}

#----------------------------------------------------------------------------------------------
function deploy.containerVersion()
{
    local -r line=${1:?}
    local -r json=${2:?}

    local container orgimage service srvc version
    local -r awkCode="$(mktemp)"

    cat <<'EOF' > "$awkCode"
#!/usr/bin/awk -f
# change  image: ${DOCKER_REGISTRY:-afeoscyc-mw.cec.lab.emc.com/}${DEV_TEAM:-devops/}${CONTAINER_OS:-alpine}/kafka/${KAFKA_VERSION:-2.1.0}:${CONTAINER_TAG:-6ccfce35746b02604f59e1f956cb237548baf4ad172400b7f961b646f70a2740}
# to      image: ${DOCKER_REGISTRY:-afeoscyc-mw.cec.lab.emc.com/}devops/alpine/kafka/2.1.0:6ccfce35746b02604f59e1f956cb237548baf4ad172400b7f961b646f70a2740
{
  end = split($0,arr,"$");
  i = 1;
  for ( i=1; i<= end; i++ ) {
    if (i == 1)
      x = arr[i];
    else if (i == 2)
      x = x "$" arr[i];
    else {
      sub("{.+-", "", arr[i]);
      sub("}", "", arr[i]);
      x = x arr[i];
    }
  }
  print x;
}
EOF

    local -r image="$(sed -E 's|\s+image:\s+(.+)$|\1|' <<< "$line")"
    while read -r srvc; do
        service=$(jq ".services.$srvc" <<< "$json")
        [ $(jq -r '.image' <<< "$service") = "$image" ] || continue

        container=$(jq -r '.container_name' <<< "$service")
        version=$(docker inspect "$container" | jq -r '.[].Config.Labels."container.fingerprint"')
        [ "$version" != 'null' ] || break
        orgimage="$(docker inspect "$container" | jq -r '.[].Config.Image')"

        newline="$line"
        [ "$(grep -cs 'CONTAINER_TAG' <<< "$newline")" -eq 0 ] || newline="${line%\${CONTAINER_TAG*}"'${CONTAINER_TAG:-'$version'}'

        echo -n '{'
        echo -n '"orgline":"'${line}'",'
        echo -n '"orgimage":"'$(eval echo $image)'",'
        echo -n '"version":"'$version'",'
        echo -n '"newline":"'"$newline"'",'

        [ "$(grep -cs 'CONTAINER_TAG' <<< "$newline")" -eq 0 ] || newline="${line%\${CONTAINER_TAG*}"
        [ "$(grep -cs "$version" <<< "$newline")" -eq 0 ]      || newline="${newline%:*}:"
        newline="${newline%:*}:$version"
        echo -n '"promoted":"'$(awk -f "$awkCode" <<< "$newline")'",'
        echo '"newimage":"'${orgimage%:*}:$version'"}'
        break

    done < <(jq -r '.services|keys[]' <<< "$json")
    rm "$awkCode"
}

#----------------------------------------------------------------------------------------------
function deploy.createVolumeFolders()
{
    local json="${1:?}"
    local service_name="${2:?}"

    local -a dirs=(jq '.' "$json" )
    mapfile -t dirs < <(jq -r ".services.${service_name}.volumes[]?" <<< "$json" \
                       | awk -F ':' '{print $1}' \
                       | grep -v '/docker' \
                       | grep -Ev '^~' \
                       | sort -u ||:)
    [ "${#dirs[*]}" -gt 0 ] || continue

    local dir
    for dir in "${dirs[@]}"; do
        [ "${dir:0:2}" = './' ] && dir="${dir:2}"                        # remove './' prefix
        # initialize dir when needed
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir" ||:
            sudo chown "$EUID" "$dir"
            [ "$dir" = "${service_name}/log" ] && chmod 777 "$dir"
        fi

        # ensure log symlinks are setup
        if [ "$dir" = "${service_name}/log" ] && [ "$(readlink "${LOG_DIR}/$service_name")" != "${WORKSPACE_DIR}/$dir" ]; then
            # get rid of any old stuff that may prevent us creating symlink
            [ -f "${LOG_DIR}/$service_name" ] && sudo rm "${LOG_DIR}/$service_name"
            [ -h "${LOG_DIR}/$service_name" ] && sudo rm "${LOG_DIR}/$service_name"
            ln -s "${WORKSPACE_DIR}/$dir" "${LOG_DIR}/$service_name"
        fi
    done
}

#----------------------------------------------------------------------------------------------
# determine changes to line of 'docker-compose'
# called after containers are running so that up-to-date config info is available
function deploy.fixupDCLineAfterRun()
{
    local line="${1:?}"
    local json="${2:?}"
    local property="${3:?}"       # property for 'jq' to select from JSON:  '.newline' or '.promoted'

    # update image definition
    if grep -qsE '^\s+image:\s' <<< "$line"; then
        # update workspace/docker-compose.yml when we pull latest images
        deploy.containerVersion "$line" "$json" | jq -r "$property"
        return 0
    fi

    # update any versions.  (search for string containing  '${SOMEMODULE_VERSION:-xxxxxxxxxxxxxxx}'
    if grep -qsE '^\s+.+\${[A-Z0-9]+_VERSION:-' <<< "$line"; then
        # 'keyName' is 'SOMEMODULE_VERSION',  '!keyName' is the current/new value of 'xxxxxxxxxxxxxxx'
        local keyName=$(sed -E 's|^\s+.+\$\{([A-Z0-9]+_VERSION):-[^}]+}.*$|\1|' <<< "$line")
        sed -E 's|^(\s+.*\$\{'${keyName}':-)[^\}]+(}.*)$|\1'${!keyName}'\2|' <<< "$line"
    fi
    return 0
}

#----------------------------------------------------------------------------------------------
# determine changes to line of 'docker-compose'
# called before containers are running so that the workspace 'docker-compose' contains latest user changes
function deploy.fixupDCLineBeforeRun()
{
    local line="${1:-}"
    [ -z "${line:-}" ] && return 0

    # skip comments
    grep -vE '^\s*#' <<< "$line" && return 0

    # update any versions.  (search for string containing  '${SOMEMODULE_VERSION:-xxxxxxxxxxxxxxx}'
    if grep -qsE "$line" -f <(versions.get "$CONTAINER_OS" 'echo' | sed -s 's|=.*$||'); then
        # replace version with with actual value in string similar to "${JENKINS_VERSION:-2.164.1}"
        # ie: find 'JENKINS_VERSION' then replace '2.164.1' with value from 'versions' file
        local version
        for version in $(versions.get "$CONTAINER_OS" 'echo'); do
            [ -z "${version:-}" ] && continue                # skip empty strings
            grep -sqE '^\s*#' <<< "$version" && continue     # skip comments
            # sed expression uses BASH string concatenation to combine regex with BASH variables
            sed -r -e 's|(\\\$\{'"${version%=*}"':-)[^\}]+\}|\1'"${version##*=}"'\}|g' <<< "$line"
        done
        return 0
    fi

    # update default OS with actual OS from container.os file
    if [ "${CONTAINER_OS}" != 'alpine' ] && grep -qsE 'alpine' <<< "$line"; then
        sed -e 's|alpine|'"${CONTAINER_OS}"'|' <<< "$line"
        return 0
    fi
    return 0
}

#----------------------------------------------------------------------------------------------
# setup workspace if it does not exist
function deploy.initialize()
{
    # create WORKSPACE_DIR/docker-compose.yml
    deploy.refreshDockerCompose

    # ensure our log dir exists
    [ -d "$LOG_DIR" ] || mkdir -p "$LOG_DIR" ||:


    local dc_yaml="${WORKSPACE_DIR}/docker-compose.yml"
    local json="$(docker.yamlToJson "$dc_yaml")"
    local -ri num_secrets=$(jq '.services[]|select(has("secrets"))|.secrets[]' <<< "$json" | wc -l)
    [ "$num_secrets" -eq 0 ] || [ -d "$SECRETS_DIR" ] || deploy.populateSecrets "$SECRETS_DIR"


    # create the folders which are mounted by containers (defined in docker-compose volumes)
    local -A service_tasks=()
    for service_name in $(docker.services "$dc_yaml"); do

        # look for individual service tasks (to run later)
        if [ ! -d "$service_name" ]; then
            local initFunction="${CONFIG_DIR}/${service_name}.setup"
            [ -e  "$initFunction" ] && service_tasks["$service_name"]="$initFunction"
        fi

        # get any defined volumes
        deploy.createVolumeFolders "$json" "$service_name"
    done


    # now run our service tasks
    for task in $(printf '%s\n' "${!service_tasks[@]}" | sort); do
        chmod a+rx "${service_tasks[$task]}"
        "${service_tasks[$task]}" ||:
    done

    # update secret references (cannot apply these with other docker-compose.yml updates)
    [ "$num_secrets" -eq 0 ] || deploy.updateSecretRefs "$dc_yaml"
}

#----------------------------------------------------------------------------------------------
function deploy.main()
{
    local -A opts
    eval opts=( ${1:?} )
    readonly opts
    shift
    local -ra args=( "$@" )

    deploy.__initGlobals "${opts['base']}" "${opts['latest']:-}"

    [ -z "${opts['clean']:-}" ] || deploy.clean
    mkdir -p "$WORKSPACE_DIR" ||:


    # temporarily reduce DEBUG_TRACE to prevent 'git' tracing
    (( DEBUG_TRACE-- )) ||:
    versions.data "$VERSIONS_INFO" "${CONTAINER_TAG:-}"
    versions.get "$CONTAINER_OS" 'export'
    (( DEBUG_TRACE++ )) ||:

    if [ "${opts['init']:-}" ]; then
        #  initialize devops_container_environment
        term.log '$deploy.initialize 2>&1 | tee setup.log\n' 'grey'
        deploy.initialize 2>&1 | tee "${WORKSPACE_DIR}/setup.log"
        exit 0
    fi

    local dc_yaml="${WORKSPACE_DIR}/docker-compose.yml"
    if [ "${opts['down']:-}" ] && [ -f "$dc_yaml" ]; then
        # stop any running containers
        term.log '\nINFO: bringing down containers\n' 'white'
        term.log 'docker-compose --file '"$dc_yaml"' down\n' 'grey'
        docker-compose --file "$dc_yaml" down ||:
        exit 0
    fi


    #  restart devops_container_environment  (performs configuration if needed)
    term.log '$deploy.restart 2>&1 | tee restart.log\n' 'grey'
    deploy.restart 2>&1 | tee "${WORKSPACE_DIR}/restart.log"


    #  update production files if this is for promotion
    [ -z "${opts['promote']:-}" ] || deploy.toProduction
}

#----------------------------------------------------------------------------------------------
function deploy.passwordSecret()
{
    local -r json=${1:?}
    local -r service=${2:?}
    local -r pwdVar=${3:?}

    local secret jqquery
    local password="$(jq -r '.services.'${service}'.environment.'${pwdVar} <<< "$json" )"
    if [ "$password" = 'null' ];then
        password="$(jq -r '.services.'${service}'.environment.'${pwdVar}'_FILE' <<< "$json" )"
        secret="$(basename "$password")"
        jqquery='.secrets."'"${secret}"'".file'
        local pwd_file="$(eval echo "$(jq -r "$jqquery" <<< "$json" )")"
        [ -e "$pwd_file" ] || trap.die "Password file: '$pwd_file' not found. Used by startup of service: $service"
        password=$(< "$pwd_file")
    fi
    echo "$password"
}
export -f deploy.passwordSecret

#----------------------------------------------------------------------------------------------
function deploy.populateSecrets()
{
    local -r secrets_dir=${1:-}

    term.log 'populating secrets\n'
    if [ -z "${CFG_USER_SECRETS:-}" ]; then
        [ "${OPEN_SECRETS_REPO:-}" ] || trap.die  "no definition provided for 'secrets'"
        mkdir -p "$(dirname "$secrets_dir")"
        git.clone "$OPEN_SECRETS_REPO" "$secrets_dir"

    elif [ -d "${CFG_USER_SECRETS}" ] &&  [ "$(readlink -f "$CFG_USER_SECRETS")" != "$(readlink -f "$secrets_dir")" ]; then
        mkdir -p "$secrets_dir"
        cp -r "${CFG_USER_SECRETS}"/* "$secrets_dir"/

    elif git.lsRemote "${CFG_USER_SECRETS}" &> /dev/null ; then
        mkdir -p "$(dirname "$secrets_dir")"
        git.clone "$CFG_USER_SECRETS" "$secrets_dir" --quiet
        if [ "$(grep -cs 'git-crypt' "${secrets_dir}/.gitattributes")" -gt 0 ]; then
            [ -e "${CRYPT_FILE:-}" ] || trap.die "secrets are encoded, but CRYPT_FILE: '${CRYPT_FILE:-}' does not exist"
            (cd "$secrets_dir"; git.cryptUnlock )
        fi

    else
        trap.die  "missing 'secrets' directory in WORKSPACE_DIR"
    fi
}

#----------------------------------------------------------------------------------------------
function deploy.pushImages()
{
    local -r dc_yaml=${1:?}

    local image service srvc
    local -a images=()

    local -r json=$(docker.yamlToJson "$dc_yaml")

    # extract images from docker-compose
    while read -r srvc; do
        service=$(jq ".services.$srvc" <<< "$json")
        image="$(eval echo "$(jq -r '.image' <<< "$service")" )"
        images+=( "$image" )
    done < <(jq -r '.services|keys[]' <<< "$json")

    docker.pushRetained 1 "${images[@]}"
}

#----------------------------------------------------------------------------------------------
function deploy.refreshContainers()
{
    local -r dc_yaml=${1:?}

    # make sure we start the correct versions
    if [ "$(deploy.containerTag)"  = 'dev' ]; then
        return 0
    elif [ "${CONTAINER_TAG:-}" = 'latest' ]; then
        term.log '\nINFO: updating containers to latest versions\n' 'white'
    else
        term.log '\n'"INFO: using container fingerprints defined in docker-compose.yml"'\n' 'white'
    fi
    term.log 'docker-compose --file '"$dc_yaml"' pull\n' 'grey'
    docker-compose --file "$dc_yaml" pull || return 1
}

#----------------------------------------------------------------------------------------------
function deploy.refreshDockerCompose()
{
    mkdir -p "$WORKSPACE_DIR" ||:
    cd "$WORKSPACE_DIR"

    # update skip.wait & docker-compose
    cp "${CONFIG_DIR}/skip.wait" "${WORKSPACE_DIR}/skip.wait"
    if deploy.updateFile "$CONFIG_YAML" "${WORKSPACE_DIR}/docker-compose.yml" deploy.fixupDCLineBeforeRun; then
        term.log "\nINFO: updating ${WORKSPACE_DIR}/docker-compose.yml"'\n' 'white'
    fi
}

#----------------------------------------------------------------------------------------------
function deploy.removeCBFlogs()
{
    for dir in $(find "$WORKSPACE_DIR" -mindepth 2 -maxdepth 2 -type d -name log); do
        [ -f "${dir}/cbf.log" ] || continue
        sudo rm "${dir}/cbf.log"
    done
}

#----------------------------------------------------------------------------------------------
function deploy.replaceIpAddresses()
{
    local -r filename=${1:?}
    local -r host_ip=${2:?}

    if [ -e "$filename" ]; then
        local -r ip_match_rgx='((1?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9][0-9]?|2[0-4][0-9]|25[0-5])'
        local expr="'s#${ip_match_rgx}#${host_ip}#g'"
        eval sed -i -r -e "$expr" "$filename"
    fi
}
export -f deploy.replaceIpAddresses

#----------------------------------------------------------------------------------------------
function deploy.restart()
{
    echo "CONTAINER_TAG: ${CONTAINER_TAG:-}" >&2

    # initialize workspace if required 'docker-compose.yml' is missing
    local -r dc_yaml="${WORKSPACE_DIR}/docker-compose.yml"
    if [ -f "$dc_yaml" ]; then
        deploy.refreshDockerCompose
    else
        deploy.initialize
    fi
    deploy.removeCBFlogs

    # restart our environment
    if ! deploy.restartContainers "$dc_yaml"; then
        term.log 'Failed to succussfully deploy container services.\n' 'white'
        exit 1
    fi

    local -r run_log="${WORKSPACE_DIR}/run.log"
    deploy.waitForInitializationComplete "$dc_yaml" "$run_log"

    term.log '\nINFO: removing old containers\n' 'white'
    docker.rmOldContainers

    docker.showProcessReport
    echo

    if [ "${INITIALIZATION:-}" ]; then
        term.log "Initializing complete. If this setup includes a web server, please open the following URL in your browser: http://$HOST_IP"'\n' 'white'
    fi
    exit 0
}

#----------------------------------------------------------------------------------------------
function deploy.restartContainers()
{
    local -r dc_yaml=${1:?}
    local -i status

    # stop any running containers
    term.log '\nINFO: bringing down containers\n' 'white'
    term.log 'docker-compose --file '"$dc_yaml"' down\n' 'grey'
    docker-compose --file "$dc_yaml" down ||:

    set -o verbose
    sudo find -L "$LOG_DIR" -type f ! -name '.*' -delete
    set +o verbose

    deploy.refreshContainers "$dc_yaml" && status=$? || status=$?
    [ $status -eq 0 ] || return $status

    term.log '\nINFO: bringing up containers\n' 'white'
    term.log 'docker-compose --file '"$dc_yaml"' up --detach\n' 'grey'
    # docker-compose v1.17.0 does not like '--detach'!
    docker-compose --file "$dc_yaml" up -d  && status=$? || status=$?
    [ $status -eq 0 ] || return $status

    # fixup docker-compose.yml to reflect the image versions in use
    if [ "${CONTAINER_TAG:-}" = 'latest' ]; then
        # Updating reference docker-compose.yml
#        deploy.updateContainerReferences "$CONFIG_YAML" 'promote'
        deploy.updateContainerReferences "$dc_yaml"
    fi
    return 0
}

#----------------------------------------------------------------------------------------------
function deploy.reTagImages()
{
    local -r dc_yaml=${1:?}

    local image tag
    local orgtag=$(git.branch)
    while read -r image; do
        image="$(eval echo $image)"
        if [ $(docker images | grep -cs "$image") -gt 0 ]; then
#            image="${image%=*}"
#           tag="${image##*=}"
            term.log "renaming $image to ${image%=*}:$CONTAINER_TAG"'\n' 'warn'
            docker tag "$image" "${image%=*}:$CONTAINER_TAG"
        else
            term.log "no images matching $image"'\n' 'warn'
        fi
    done < <(grep -E '^\s+image:\s' "$dc_yaml" | sed -E -e 's|^\s+image:\s+||' )
}

#----------------------------------------------------------------------------------------------
function deploy.showInitializationBanner()
{
    term.log '******************************************************************************\n' 'white'
    term.log '*                                                                            *\n' 'white'
    term.log "*  initializing DevOps Container Environment on $(environ.ipAddress)"'\n'         'white'
    term.log '*                                                                            *\n' 'white'
    term.log '******************************************************************************\n' 'white'
    export INITIALIZATION='true'
}

#----------------------------------------------------------------------------------------------
function deploy.toProduction()
{
    #  verify repo is not dirty
    #  verify latest is running
    #  verify branch is not protected

    #  retag images
    #  push images to registry
    #  update workspace docker-compose
    #  update deploy docker-compose

    #  update main docker-compose.yml if this is for promotion
    if [ "${CONTAINER_TAG:-}" != 'latest' ]; then
        deploy.reTagImages "$dc_yaml"
        # Updating reference docker-compose.yml
        deploy.updateContainerReferences "$CONFIG_YAML" "${opts['promote']}"
        # now update docker registry
        deploy.pushImages "$dc_yaml"
    fi
}

#----------------------------------------------------------------------------------------------
function deploy.updateContainerReferences()
{
    local -r dc_yaml=${1:?}
    local -r promoted=${2:-}

    local property
    if [ "${promoted:-}" ]; then
        property='.promoted'
    else
        term.log '   Updating '"$dc_yaml"'\n'
        property='.newline'
    fi

    local -r json=$(docker.yamlToJson "$dc_yaml")
    deploy.updateFile "$CONFIG_YAML" "$dc_yaml" deploy.fixupDCLineAfterRun "$json" "$property" ||:
}

#----------------------------------------------------------------------------------------------
function deploy.updateFile()
{
    local -r srcfile=${1:?}
    local -r dstfile=${2:?}
    local process=${3:?}
    shift 3

    local line newline tmp_file
    local -i status

    tmp_file="${dstfile#.*}.tmp"
    (while read -r line; do
        if [ -z "${line:-}" ] || grep -sq '^\s+$' <<< "$line" ; then
            echo
            continue
        fi
        newline=$("$process" "$line" "$@") && status=$? || status=$?
        [[ "$status" -ne 0 || -z "${newline:-}" ]] && newline="$line"
        if [ "${2:-}" = '.promoted' ]; then
            echo "$newline"
            continue

        elif [ "$(grep -cEs ':\?}' <<< "$newline")" -gt 0 ]; then
            local indent="$(sed -Ee 's|^(\s+).*$|\1|' <<< "$newline")"
            newline="$(eval echo $newline)"
            echo "${indent}$newline"

        else
            echo "$newline"
        fi
    done < <(cat "$srcfile")) > "$tmp_file"

    # if there are no changes, delete tmp file
    if [ "$(lib.fileSha256 "$dstfile")" = "$(lib.fileSha256 "$tmp_file")" ]; then
        rm "$tmp_file"
        return 1   # no updates
    else
        # otherwise rename 'srcfile' to file.YYYYMMDDhhmmss.bak and rename updated file to 'dstfile'
        # create backup of dstfile before we update it
        if [ -f "$dstfile" ]; then
            local backup="${dstfile%.*}.$(date +"%Y%m%d%H%M%S").${dstfile##*.}.bak"
            backup="$(dirname "$backup")/~$(basename "$backup")"
            mv "$dstfile" "$backup"
        fi
        mv "$tmp_file" "$dstfile"
        return 0   # file updated
    fi
}

#----------------------------------------------------------------------------------------------
function deploy.updateSecretRefs()
{
    local -r dc_yaml=${1:?}
    sed -i -r -e "s|file:\s+~/|file: /home/bobb/|"   "$dc_yaml"
}

#----------------------------------------------------------------------------------------------
function deploy.validateDockerComposeYaml()
{
    local -r dc_yaml=${1:?}
    [ $(jq '.services[].ports[]' <<< "$dc_yaml" | sort | wc -l) -eq $(jq '.services[].ports[]' <<< "$dc_yaml"| sort -u) ] || return 1
}

#----------------------------------------------------------------------------------------------
function deploy.waitForInitializationComplete()
{
    local -r dc_yaml=${1:?}
    local -r run_log=${2:?}

    # get the list of containers we will be checking
    local -a containers
    mapfile -t containers < <(docker.services "$dc_yaml")


    # initialize the log
    echo "Started at: ${START_TIME}" > "$run_log"

    local -A finished=( )
    local -a lines=()
    local container line
    local -i index=1

    term.log '\n'"INFO: waiting for ${#containers[*]} containers to complete their startup"'\n' 'white'
    while [ "${#finished[*]}" -lt "${#containers[*]}" ]; do
        # sleep 5 secs between scans
        sleep 5
        lines=()

        # check all known containers
        for container in "${containers[@]}"; do
            # ignore any that are defined in 'skip.wait'
            if [ $(grep -cs "$container" "${WORKSPACE_DIR}/skip.wait") -gt 0 ] && [ -z "${finished[${container,,}]:-}" ]; then
                printf '%02d. %s: skipping wait.\n' $(( index++ )) "${container^^}"
                finished[$container]='0'
            fi

            # look for specific 'end of startup' string in logs
            local text="$(docker logs "${container,,}" 2>&1 | grep -s "Finished executing startup" | head -1 ||: )"
            [ "$text" ] || continue                                        # ignore blank lines
            [ "${container,,}" ] || continue                               # ignore invalid container
            [ -z "${finished[${container,,}]:-}" ] || continue             # ignore if we already have this result

            # keep track of what has finished
            finished[${container,,}]="$text"
            lines+=( "$(sed -Ee 's|^.+Finished executing startup scripts after ||' <<< "$text" | awk -F ':' '{ print ((($1 * 60) + $2) * 60) + $3 }')_${container,,}" )
        done

        # print out any containers we foound in this scan
        [ "${#lines[*]}" -gt 0 ] || continue
        for line in $(printf '%s\n' "${lines[@]}" | sort -t '_' -k 1n,2); do   # sort by time taken to finish startup
            container="${line##*_}"                                            # extract container name
            container="${container,,}"
            printf '%02d. %s\n' $(( index++ )) "${finished[${container}]:-}"
            docker logs "${container}" >> "$run_log" 2>&1                      # grab the log
        done
    done

    # update the run.log from each 'docker logs'
    for container in "${containers[@]}"; do
        if [ $(grep -cs "$container" "${WORKSPACE_DIR}/skip.wait") -gt 0 ]; then
            echo >> "$run_log" 2>&1
            echo '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>' >> "$run_log" 2>&1
            echo "${container}" >> "$run_log" 2>&1
            echo >> "$run_log" 2>&1
            docker logs "${container}" >> "$run_log" 2>&1                      # grab the log
        fi
    done
}

#----------------------------------------------------------------------------------------------
function deploy.workspace()
{
    local -r base_dir=${1:?}
    echo "${base_dir}/workspace.$(basename "$base_dir")"
}

#----------------------------------------------------------------------------------------------
