#!/bin/bash

export KAFKA_BOOTSTRAP_SERVERS="${KAFKA_BOOTSTRAP_SERVERS:-10.1.3.6:9092,10.1.3.10:9092,10.1.3.11:9092}"
export MAX_IMAGES_TO_KEEP=10
export PROGRESS_LOG


#----------------------------------------------------------------------------------------------
function build.all()
{
    local -r top=${1:?}
    shift
    local -ra userInput=( "$@" )

    cd "$top"
    local branch="$(git branch | grep '* ' | awk '{print $2}')"
    [ "$branch" != 'dev' ] || versions.data ".versions" 'LATEST'


    local -a OSes
    mapfile -t OSes < <(sed '/^[[:blank:]]*#/d;s/[[:blank:]]*#.*//' container.os)
    [ "${CONTAINER_OS:-}" ] && OSes=( $CONTAINER_OS )
    local cbf_version="${CBF_VERSION:-master}"

    for containerOS in "${OSes[@]}"; do
        [ ${containerOS:-} ] || continue
        [ -e "$(versions.DIRECTORY)/$containerOS" ] || continue
        [ "${cbf_version:-}" ] && CBF_VERSION="$cbf_version"

        (build.containersForOS "$containerOS" "${userInput[@]:-}")   # run in separate shell to avoid "VERSIONS" conflicting
    done
}
export -f build.all

#----------------------------------------------------------------------------------------------
function build.canPush()
{
    local -r revision=${1:?}

    [ "${DOCKER_ALWAYS_PUSH:-}" ] && return 0
    [[ "$revision" != *dirty ]] || return 1

#    [ "$CONTAINER_GIT_REFS" = 'master' ]

    return 0
}
export -f build.canPush

#----------------------------------------------------------------------------------------------
function build.changeImage()
{
    local taggedImage=${1:?}
    local actualImage=${2:?}

    [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}'  --filter "reference=$taggedImage")" ] || \
        [ "$(docker ps --format '{{.Image}}' | grep "$taggedImage")" ] || \
        docker rmi "$taggedImage"

    [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$actualImage")" ] || \
        docker tag "$actualImage" "$taggedImage"
}
export -f build.changeImage

#----------------------------------------------------------------------------------------------
function build.containersForOS()
{
    local -r containerOS=${1:-}
    shift
    local -ar requestModules=( "$@" )
    [ "${containerOS:-}" ] || containerOS="${CONTAINER_OS:-alpine}"


    local start=$(timer.getTimestamp)

    export CFG_GITHUB_EMAIL=''
    export CFG_GITHUB_HUBOT_TOKEN=''
    export CFG_GITHUB_JENKINS_EMAIL=''
    export CFG_GITHUB_JENKINS_NAME=''
    export CFG_GITHUB_JENKINS_TOKEN=''
    export CFG_GITHUB_JENKINS_USER=''
    export CFG_GITHUB_NAME=''
    export CFG_GITHUB_TOKEN=''
    export CFG_GITHUB_USER=''
    export CFG_PASS=''
    export CFG_SLACK_HUBOT_TOKEN=''
    export CFG_USER=''
    export DEV_TEAM="${DEV_TEAM:-devops/}"
    export DOCKER_REGISTRY=$(registry.SERVER)
    export CBF_VERSION
    export CONTAINER_OS="$containerOS"

    local logDir=logs
    [ -d "$logDir" ] || mkdir -p "$logDir"
    if [ "${BUILD_URL:-}" ]; then
        PROGRESS_LOG="$(readlink -f "$logDir")/progressInfo"
        touch "$PROGRESS_LOG"
    fi

    local build_time=$(date +%Y%m%d-%H%M%S.%N -u)
    local fingerprint="n/a"
    local git_commit=$(git rev-parse HEAD)
    local git_url="$(git remote get-url origin)"
    local origin=$(git describe --tags --dirty --always)
    local git_refs="$(git log -n1 --oneline --decorate | sed 's/[^\(]*(\([^\)]*\)).*/\1/')"

    echo
    echo -n 'building '
    echo -en '\e[94m'
    echo -n "$git_url"
    echo -e '\e[0m'
    echo "    container OS:   $containerOS"
    echo "    refs:           (${git_refs})"
    echo "    commitId:       $git_commit"
    echo "    revision:       $origin"

    # get versions  (do not redefine any that are alresady in ENV)
    versions.get "$containerOS" 'export'

    exec 3>&1  # create special stdout

    local -i status=0
    while read -r dir; do
        if [ ! -d "$dir" ]; then
            echo "invalid project directory: $dir"
            continue
        fi

        pushd "$dir" >/dev/null
        build.module && status=$? || status=$?
        popd >/dev/null
        [ $status -eq 0 ] || break
    done< <( build.verifyModules "$containerOS" "$(printf '%s\n' "${requestModules[@]}")" )

    exec 3>&-   # close special stdout

    # delete empty logs
    find "$logDir" -type f -size 0 -delete

    local finish=$(timer.getTimestamp)
    local -i elapsed=$(( finish - start ))

    echo
    echo
    TZ='America/New_York' date
    local duration="$(timer.fmtElapsed $elapsed)"
    printf 'Time elapsed: %s\n' "$duration"

    [ -z "${BUILD_URL:-}" ] || :> "$PROGRESS_LOG"
    build.logToKafka "$build_time" \
                     "$fingerprint" \
                     "$git_commit" \
                     "$git_url" \
                     "$origin" \
                     "$duration" \
                     "$elapsed" \
                     "$git_refs"

    return $status
}
export -f build.containersForOS

#----------------------------------------------------------------------------------------------
function build.dependencyInfo()
{
    # get the following
    #  - git tree hash
    #  - resolved 'docker build.args' config (without reference to FROM_BASE) from docker-compose.yml
    #  - container digest of layer that we are building on top of
    #  - anything dirty in workspace
    #  - sha from CBF

    # SIDE EFFECTS:
    #  - ensure any FROM_BASE is local
    #  - sets CBF_VERSION

    local -r config=${1:?}


    # git tree hash
    git ls-tree HEAD -- . | awk '{print $3}'

    # resolve 'docker build.args' config (without reference to FROM_BASE) from docker-compose.yml
    set +u
    eval echo $(jq '.build.args | del(.FROM_BASE)' <<< "$config")
    set -u


    # container digest of layer that we are building on top of
    local base=$(eval echo $( jq '.build.args.FROM_BASE' <<< "$config" ))
    if [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$base")" ]; then
        echo pulling parent image: "$base" >&2
        [ "$(docker image ls "$base" | awk 'NR != 1')" ] || docker pull "$base" >&2 || return 0
    fi
    docker inspect "$base" | jq '.[].Id'          # digest sha from parent


    # anything dirty in workspace
    while read -r line; do
        local file=$(awk '{print $2}' <<< "$line")
        case $(awk '{print $1}' <<< "$line") in
            A|M|MM)
                sha256sum "$file";;
            *)
                echo "$line";;
        esac
    done < <(git status --porcelain)


    # add our cbf version
    local localDir
    [ -d build ] && localDir="$(ls -1A build/ | grep 'container_build_framework')"
    if [ ${localDir:-} ]; then
        # generate fingerprint from all our dependencies
        echo -n 'local-'
        sha256sum <<< "$(build.dirChecksum "$localDir")" | cut -d' ' -f1

    elif [ $(basename "$(pwd)") = 'base_container' ]; then
        if [ "${CBF_VERSION:-}" ]; then
            :
        elif [ -d "../container_build_version" ]; then
            export CBF_VERSION=$(cd ../container_build_version; git describe --tags --dirty --always)
        else
            die 'no version specified for CBF'
        fi
        echo "$CBF_VERSION"

    else
        # use parent's cbf.version
        docker inspect "$base" | jq '.[].Config.Labels."container.cbf.version"?' | tr -d '"'
    fi
}
export -f build.dependencyInfo

#----------------------------------------------------------------------------------------------
function build.dirChecksum()
{
    local -r dir=${1:?}

    # add any local 'build/container_build_framework' folder
    while read -r file; do
        sha256sum "$file"
    done < <(find "$dir" -type f -name '*' 2>/dev/null ||:)
}
export -f build.dirChecksum

#----------------------------------------------------------------------------------------------
function build.dockerCompose()
{
    local -r compose_yaml="${1:?}"

    local jsonConfig=$( build.yamlToJson "$compose_yaml" | jq '.services?' )
    if [ "${jsonConfig:-}" ]; then
        local -r service="$(jq 'keys[0]?' <<< "$jsonConfig" | tr -d '"')"
        [ -z "${service:-}" ] || jq $(eval echo "'.\"$service\"?'") <<< "$jsonConfig"
    fi
}
export -f build.dockerCompose

#----------------------------------------------------------------------------------------------
function build.findIdsWithFingerprint()
{
    local -r fingerprint=${1:?}

    curl --silent \
         --unix-socket /var/run/docker.sock http://localhost/images/json \
         | jq ".[]|select(.Labels.\"container.fingerprint\" == \"$fingerprint\").RepoTags[]" \
         | tr -d '"'
}
export -f build.findIdsWithFingerprint

#----------------------------------------------------------------------------------------------
function build.parentChild()
{
    local os=${1:-}

    local -i index=0
    local -r skip_builds_file='skip.build'
    echo '['
    while read -r dc_yaml; do
        [ -e "$skip_builds_file" ] && [ $(grep -cH "$(dirname "$dc_yaml")" "$skip_builds_file" 2>/dev/null | awk -F ':' '{print $2}') -eq 0 ] || continue
        local definedOS=$(grep -E '^#\s+containerOS:\s+' "$dc_yaml")
        [ "${definedOS:-}" ] && [ $(grep -cH "$os" <<< "$definedOS" | awk -F ':' '{print $2}') -eq 0 ] && continue

        (( index++ )) && echo -n ','
        eval echo $(build.yamlToJson "$dc_yaml" | jq '.services[]|{parent: .build.args.FROM_BASE, image: .image}|tojson')

    done < <(find . -mindepth 2 -maxdepth 2 -name 'docker-compose.yml' | awk '{print substr($0,3)}')
    echo ']'
}
export -f build.parentChild

#----------------------------------------------------------------------------------------------
function build.jsonParentChild()
{
    local os=${1:-}

    build.parentChild "$os" | jq '. as $data |
        def dependentsOf($f): [ $data[]|select(.parent == $f)|.image ];
        def parentsOf($f): [ $data[]|select(.image == $f)|.parent ];
        def composeTree: [ $data[].parent ] | unique | map( {"image":.,"parent": parentsOf(.) } );
        def dependentTree: [ $data[].image ] | unique | map( {"image":.,"dependents": dependentsOf(.) } );
        def rootImages: composeTree[]|select(.parent|length == 0)|.image;
        dependentTree'
}
export -f build.jsonParentChild

#----------------------------------------------------------------------------------------------
function build.logger()
{
    local msg=${1:?}

    if [ "${BUILD_URL:-}" ]; then
        if [[ $msg == checking* ]] || [[ $msg == *'has not changed.' ]]; then
            echo "    $msg" >&3
        else
            echo -e "    \e[32m$msg\e[0m" >&3
        fi
        echo "$msg" >> "$PROGRESS_LOG"
    fi
    echo "    $msg"
}
export -f build.logger

#----------------------------------------------------------------------------------------------
function build.logToKafka()
{
    local -r build_time=${1:-}
    local -r fingerprint=${2:-}
    local -r git_commit=${3:-}
    local -r git_url=${4:-}
    local -r origin=${5:-}
    local -r duration=${6:-}
    local -r elapsed=${7:-}
    local -r git_refs=${8:-}
    local -r status=${9:-}

    local -a refs=( $git_refs )
    # create our data array that gets logged
    local -a build_data=( "$(json.encodeField "build_time" "$build_time")"
                          "$(json.encodeField "fingerprint" "$fingerprint")"
                          "$(json.encodeField "commit" "$git_commit")"
                          "$(json.encodeField "repo_url" "$git_url")"
                          "$(json.encodeField "origin" "$origin")"
                          "$(json.encodeField "duration" "$duration")"
                          "$(json.encodeField "elapsed" "$elapsed")"
                          "$(json.encodeArray "refs" $(json.arrayValues "${refs[@]}"))"
                          "$(json.encodeField "status" "$status")"
                        )
    if [ "${PROGRESS_LOG:-}" ] && [ -s "$PROGRESS_LOG" ]; then
        local -a progress_log=( $(< "$PROGRESS_LOG") )
        build_data+=("$(json.encodeArray "actions" $(json.arrayValues "${progress_log[@]}"))")
    fi

    # now log our data to kafka
    local -r kafka_producer="$(dirname $(readlink -f "${BASH_SOURCE[0]}"))/kafkaProducer.py"
    "${kafka_producer}" --server "$KAFKA_BOOTSTRAP_SERVERS"                        \
                        --topic 'container_build_data'                          \
                        --value "$( json.encodeHash '--' "${build_data[@]}" )"
    return 0
}
export -f build.logToKafka

#----------------------------------------------------------------------------------------------
function build.module()
{
    local -i startTime=$(timer.getTimestamp)

    local compose_yaml="docker-compose.yml"
    [ -e "$compose_yaml" ] || return 0
    local config=$(build.dockerCompose "$compose_yaml")


    # setup environment for 'docker-compose build'
    export CONTAINER_BUILD_TIME=$(date +%Y%m%d-%H%M%S.%N -u)
    export CONTAINER_GIT_REFS="($(git log -n1 --oneline --decorate | sed 's/[^\(]*(\([^\)]*\)).*/\1/'))"
    export CONTAINER_GIT_COMMIT="$(git rev-parse HEAD)"
    export CONTAINER_GIT_URL="$(git remote get-url origin)"
    export CONTAINER_ORIGIN="$(git describe --tags --dirty --always)"

    # generate fingerprint from all our dependencies
    local branch=$(git branch | grep '*' |  awk '{ gsub("[\\/@]","_",$2); print $2 }')
    export BASE_TAG="${BASE_TAG:-${branch}-latest}"
    export CONTAINER_FINGERPRINT="$( sha256sum <<< $(build.dependencyInfo "$config") | cut -d' ' -f1 )"

    local taggedImage="$(eval echo $(jq '.image?' <<< $config))"
    taggedImage="${taggedImage%:*}:${BASE_TAG}"

    echo
    echo -n 'building '
    echo -en '\e[94m'
    echo -n "$taggedImage"
    echo -e '\e[0m'
    echo "    refs:           ${CONTAINER_GIT_REFS:-}"
    echo "    commitId:       ${CONTAINER_GIT_COMMIT:-}"
    echo "    repo:           ${CONTAINER_GIT_URL:-}"
    echo "    fingerprint:    ${CONTAINER_FINGERPRINT:-}"
    echo "    revision:       ${CONTAINER_ORIGIN:-}"

    [ "${CONTAINER_FINGERPRINT:-}" ] || trap.die "No base image found for '$taggedImage'. Unable to calculate fingerprint."


    # get name of image tagged with fingerprint
    export CONTAINER_TAG="$CONTAINER_FINGERPRINT"
    local actualImage="$(eval echo $(jq '.image?' <<< $config))"
    local -i status=0

    # rebuild container because no container exists with the correct fingerprint
    if [ "${BUILD_URL:-}" ]; then
        # this on Jenkins
        :> "$PROGRESS_LOG"
        local logBase="${logDir}/$dir"
        (build.updateContainer "$compose_yaml" "$taggedImage" "$actualImage" "$CONTAINER_ORIGIN" >"../${logBase}.out" 2>"../${logBase}.err") \
          && status=$? || status=$?
        [ $status -eq 9 ] && rm "../${logBase}.out"

        # show location of log files if they have any content
        local log_display_base="${BUILD_URL}artifact/$logBase"
        [ -s "../${logBase}.out" ] && echo "    STDOUT log:  ${log_display_base}.out/*view*/"
        [ -s "../${logBase}.err" ] && echo "    STDERR log:  ${log_display_base}.err/*view*/"

        if [ $status -ne 0 ] && [ $status -ne 9 ]; then
          term.log "\n"
          term.log "***Error occurred while generating $taggedImage" 'error'
          echo
          echo '----------------------------------------------------------------------------------------------'
          echo
          echo  'STDOUT:'
          echo
          tail -30 ../${logBase}.out
          echo
          echo '----------------------------------------------------------------------------------------------'
          echo
          echo  'STDERR:'
          echo
          tail -30 ../${logBase}.err
          echo
          echo '----------------------------------------------------------------------------------------------'
        fi

    else
        (build.updateContainer "$compose_yaml" "$taggedImage" "$actualImage" "$CONTAINER_ORIGIN") && status=$? || status=$?
    fi
    local -i endTime=$(timer.getTimestamp)
    local -i elapsed=$(( endTime - startTime ))
    local duration="$(timer.fmtElapsed $elapsed)"
    printf '    duration:       %s\n' "$duration"
    build.logToKafka "$CONTAINER_BUILD_TIME" \
                     "$CONTAINER_FINGERPRINT" \
                     "$CONTAINER_GIT_COMMIT" \
                     "$CONTAINER_GIT_URL" \
                     "$CONTAINER_ORIGIN" \
                     "$duration" \
                     "$elapsed" \
                     "$CONTAINER_GIT_REFS" \
                     "$status"
    [ $status -eq 9 ] && status=0
    return $status
}
export -f build.module

#----------------------------------------------------------------------------------------------
function build.pushImage()
{
    local -r tagged="${1:?}"
    local -r actual="${2:-}"

    local -r prefix='#\s+max\s+registry\s+entries:'
    local max_images=$(grep -E "$prefix" "$compose_yaml" | sed -r "s|${prefix}\s+(\d+)|\1|")
    : ${max_images:=$MAX_IMAGES_TO_KEEP}
    registry.pushImage "$max_images" "$tagged" "$actual"
}
export -f build.pushImage

#----------------------------------------------------------------------------------------------
function build.resolveCbfReference()
{
    local cbf_version=${1:?}

    local branch="${cbf_version:-}"
    case "${branch:-}" in
        master|integration)
            ;;
        latest)
            branch='dev'
            ;;
        *)
            echo '$branch'
            return 0
            ;;
    esac

    echo -n 'v0.0-00-g'
    wget -qO- "https://api.github.com/repos/ballab1/container_build_framework/git/refs/heads/${branch}" | jq '.object.sha' | awk '{substr($1,2,8)}'
}
export -f build.resolveCbfReference

#----------------------------------------------------------------------------------------------
function build.updateContainer()
{
    local -r compose_yaml=${1:?}
    local -r taggedImage=${2:?}
    local -r actualImage=${3:?}
    local -r revision=${4:-}

    if [ -z "${ALWAYS_BUILD:-}" ]; then
        build.logger "checking for local $taggedImage with the correct fingerprint"
        local -a images
        mapfile -t images < <(build.findIdsWithFingerprint "$CONTAINER_FINGERPRINT")
        if [ ${#images[*]} -gt 0 ]; then
            build.logger "${taggedImage} has not changed."
            local -i doPush=0
            if [ $(printf '%s\n' "${images[@]}" | grep "$taggedImage" | wc -l) -eq 0 ]; then
                # found image by a different 'name:tag'
                docker tag "${images[0]}" "$taggedImage"
                doPush=1
            elif [ "${DOCKER_ALWAYS_PUSH:-}" ]; then
                doPush=1
            fi
            [ $doPush -eq 0 ] || build.pushImage "$taggedImage"
            return 9
        fi

        # check if there is an image in the registry with the correct fingerprint
        build.logger "checking if $actualImage is available in registry"
        if docker pull "$actualImage" 2>/dev/null; then
            # downloaded image from registry
            build.changeImage "$taggedImage" "$actualImage"
            if [ "${DOCKER_ALWAYS_PUSH:-}" ]; then
                build.logger "pushing ${taggedImage} to registry"
                build.pushImage "$taggedImage" "$actualImage"
            fi
            docker rmi "$actualImage"
            return 9
        fi
    fi

    # rebuild container because no container exists with the correct fingerprint
    build.logger "building $actualImage"
    docker-compose -f "$compose_yaml" build 2>&1 || trap.die "Build failure"


    build.changeImage "$taggedImage" "$actualImage"
    [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$taggedImage")" ] && docker tag "$actualImage" "$taggedImage"

    if build.canPush "$revision"; then
        build.logger "pushing ${taggedImage} to registry"
        build.pushImage "$taggedImage" "$actualImage"
    fi
    docker rmi "$actualImage"
    return 0
}
export -f build.updateContainer

#----------------------------------------------------------------------------------------------
function build.verifyModules()
{
    local -r containerOS=${1:?}
    shift
    local -a requestedModules=( "$@" )
    [ "${requestedModules[*]}" ] || requestedModules=()

    local -a modules=( $(grep -Ev '^\s*#' "$(versions.DIRECTORY)/${containerOS}.modules") )
    for defMod in "${modules[@]}"; do
        if [ "${#requestedModules[*]}" -eq 0 ]; then
            echo "$defMod"
            continue
        fi

        for reqMod in "${requestedModules[@]}"; do
            [ "$reqMod" = "$defMod" ] || continue
            echo "$defMod"
        done
    done
}
export -f build.verifyModules

#----------------------------------------------------------------------------------------------
function build.yamlToJson()
{
    local -r yamlFile=${1:?}
    local -a YAML_TO_JSON=( 'python' '-c' 'import sys, yaml, json; json.dump(yaml.load(sys.stdin), sys.stdout, indent=4)' )

    if [ -e "$yamlFile"  ]; then
        "${YAML_TO_JSON[@]}" < "$yamlFile"

    elif [[ "$yamlFile" == http* ]]; then
        "${YAML_TO_JSON[@]}" <<< "$(curl --insecure --silent --request GET "$yamlFile")"

    else
        "${YAML_TO_JSON[@]}" <<< "$yamlFile"
    fi
}
export -f build.yamlToJson

#----------------------------------------------------------------------------------------------
