#!/bin/bash

export MAX_IMAGES_TO_KEEP=10
export PROGRESS_LOG


#----------------------------------------------------------------------------------------------
function build.all()
{
    local -r top=${1:?}
    shift
    local -ra userInput=( "$@" )

    local -r allStartTime=$(timer.getTimestamp)
    cd "$top"
    local logDir="$(readlink -f "$top")/logs"
    [ -d "$logDir" ] || mkdir -p "$logDir"

    local updateTo
    [[ "$(git.branch)" = *dev* ]] && updateTo=latest
    [ "${CONTAINER_TAG:-}" ] && updateTo=latest
    versions.data "${top}/.versions" "${updateTo:-}"

    local -a OSes
    mapfile -t OSes < <(sed '/^[[:blank:]]*#/d;s/[[:blank:]]*#.*//' container.os)
    [ "${CONTAINER_OS:-}" ] && OSes=( $CONTAINER_OS )

    local cbf_version="${CBF_VERSION:-}"
    if [ -z "${CBF_VERSION:-}" ]; then
        if [ -d "${top}/container_build_framework" ]; then
            cbf_version="$(build.cbfVersion)" || trap.die "Unable to save CBF to Artifactory."'\n'
        else
            cbf_version='master'
        fi
    fi

    echo "Container Build Framework version: $cbf_version"
    echo "kafka servers:  ${KAFKA_BOOTSTRAP_SERVERS:-}"
    echo
    echo

    local request_cbf="${CBF_VERSION:-}"
    for containerOS in "${OSes[@]}"; do
        [ ${containerOS:-} ] || continue
        [ -e "$(versions.DIRECTORY)/$containerOS" ] || continue
        [ "${request_cbf:-}" ] || CBF_VERSION="$cbf_version"

        (build.containersForOS "$containerOS" "${userInput[@]:-}") || break    # run in separate shell to avoid "VERSIONS" conflicting
    done


    echo
    echo
    TZ='America/New_York' date
    local build_time=$(date +%Y%m%d-%H%M%S.%N -u)
    local fingerprint="n/a"
    local git_commit=$(git.HEAD)
    local git_url="$(git.remoteUrl)"
    local origin=$(git.origin)
    local git_refs="$(git.refs)"
    local allEndTime=$(timer.getTimestamp)
    local -i allElapsed=$(( allEndTime - allStartTime ))
    local allDuration="$(timer.fmtElapsed $allElapsed)"
    printf 'Time elapsed for overall build: %s\n' "$allDuration"

    build.logToKafka "$build_time" \
                     "$fingerprint" \
                     "$git_commit" \
                     "$git_url" \
                     "$origin" \
                     "$allDuration" \
                     "$allElapsed" \
                     "$git_refs" \
                     'overall build'

    [ -d "$logDir" ] && [ $(ls -1A "$logDir" | wc -l) -gt 0 ] || rmdir "$logDir"
}
export -f build.all

#----------------------------------------------------------------------------------------------
function build.canPush()
{
    local -r revision=${1:?}

    [ "${BUILD_PUSH:-0}" != 0 ] && return 0
    if [[ "$revision" = *dirty ]]; then
        echo -n '    '
        echo -en '\e[93m'
        echo -n 'This image will not be pushed to the docker registry because it was built from a dirty repo'
        echo -e '\e[0m'
        return 1
    fi
    return 0
}
export -f build.canPush

#----------------------------------------------------------------------------------------------
function build.cbfVersion()
{
    [ -d container_build_framework ] || trap.die 'No framework directory located'
    [ -e container_build_framework/.git ] || trap.die 'CBF is not a git directory'

    local filename="$(git.origin 'container_build_framework')"
    [[ "$filename" == *-dirty* ]] && trap.die 'Please commit CBF directory prior to uploading to Artifactory'

    custom.cbfVersion
}
export -f build.cbfVersion

#----------------------------------------------------------------------------------------------
function build.changeImage()
{
    local taggedImage=${1:?}
    local actualImage=${2:?}

    [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}'  --filter "reference=$taggedImage")" ] || \
        [ "$(docker ps --format '{{.Image}}' | grep "$taggedImage")" ] || \
        docker rmi "$taggedImage"

    [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$actualImage")" ] || \
        docker tag "$actualImage" "$taggedImage"
}
export -f build.changeImage

#----------------------------------------------------------------------------------------------
function build.containersForOS()
{
    local -r containerOS=${1:-}
    shift
    local -ar requestModules=( "$@" )
    [ "${containerOS:-}" ] || containerOS="${CONTAINER_OS:-alpine}"


    local osStartTime=$(timer.getTimestamp)

    export CBF_VERSION
    export CFG_EMAIL=''
    export CFG_HUBOT_TOKEN=''
    export CFG_JENKINS_EMAIL=''
    export CFG_JENKINS_NAME=''
    export CFG_JENKINS_TOKEN=''
    export CFG_JENKINS_USER=''
    export CFG_NAME=''
    export CFG_TOKEN=''
    export CFG_USER=''
    export CFG_PASS=''
    export CFG_SLACK_HUBOT_TOKEN=''
    export CFG_USER=''
    export CONTAINER_OS="$containerOS"
    export DEV_TEAM="${DEV_TEAM:-devops/}"
    export DOCKER_REGISTRY=$(registry.SERVER)

    if [ "${BUILD_URL:-}" ]; then
        PROGRESS_LOG="$(readlink -f "$logDir")/progressInfo"
        touch "$PROGRESS_LOG"
    fi

    local build_time=$(date +%Y%m%d-%H%M%S.%N -u)
    local fingerprint="n/a"
    local git_commit=$(git.HEAD)
    local git_url="$(git.remoteUrl)"
    local origin=$(git.origin)
    local git_refs="$(git.refs)"

    echo
    echo -n 'building '
    echo -en '\e[94m'
    echo -n "$git_url"
    echo -e '\e[0m'
    echo "    container OS:   $containerOS"
    echo "    refs:           (${git_refs})"
    echo "    commitId:       $git_commit"
    echo "    revision:       $origin"

    # get versions  (do not redefine any that are alresady in ENV)
    versions.get "$containerOS" 'export'

    exec 3>&1  # create special stdout

    local -i status=0
    while read -r dir; do
        if [ ! -d "$dir" ]; then
            echo "invalid project directory: $dir"
            continue
        fi

        pushd "$dir" >/dev/null
        build.module "$containerOS" && status=$? || status=$?
        popd >/dev/null
        [ $status -eq 0 ] || break
    done< <( build.verifyModules "$containerOS" $(printf '%s\n' "${requestModules[@]}") )

    exec 3>&-   # close special stdout

    # delete empty logs
    find "$logDir" -type f -size 0 -delete

    local osEndTime=$(timer.getTimestamp)
    local -i osElapsed=$(( osEndTime - osStartTime ))

    local osDuration="$(timer.fmtElapsed $osElapsed)"
    printf '\n  Time building %s OS: %s\n' "$containerOS" "$osDuration"

    [ -z "${BUILD_URL:-}" ] || :> "$PROGRESS_LOG"
    build.logToKafka "$build_time" \
                     "$fingerprint" \
                     "$git_commit" \
                     "$git_url" \
                     "$origin" \
                     "$osDuration" \
                     "$osElapsed" \
                     "$git_refs" \
                     "$containerOS"

    return $status
}
export -f build.containersForOS

#----------------------------------------------------------------------------------------------
function build.dependencyInfo()
{
    # get the following
    #  - git tree hash
    #  - resolved 'docker build.args' config (without reference to FROM_BASE) from docker-compose.yml
    #  - container digest of layer that we are building on top of
    #  - anything dirty in workspace
    #  - sha from CBF

    # SIDE EFFECTS:
    #  - ensure any FROM_BASE is local
    #  - sets CBF_VERSION
    local -r config=${1:?}


    # git tree hash
    git.lsTree HEAD . | awk '{print $3}'

    # resolve 'docker build.args' config (without reference to FROM_BASE) from docker-compose.yml
    set +u
    eval echo $(jq '.build.args? | del(.FROM_BASE)' <<< "$config")
    set -u


    # container digest of layer that we are building on top of
    local base=$(eval echo $( jq '.build.args.FROM_BASE?' <<< "$config" ))
    if [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$base")" ]; then
        echo pulling parent image: "$base" >&2
        [ "$(docker image ls "$base" | awk 'NR != 1')" ] || docker pull "$base" >&2 || return 0
    fi
    docker inspect "$base" | jq '.[].Id?'          # digest sha from parent


    # anything dirty in workspace
    while read -r line; do
        local file=$(awk '{print $2}' <<< "$line")
        case $(awk '{print $1}' <<< "$line") in
            A|M|MM)
                sha256sum "$file";;
            *)
                echo "$line";;
        esac
    done < <(git.status --porcelain)

    # add our cbf version
    local localDir
    [ -d build ] && localDir="$(ls -1A build/ | grep 'container_build_framework')"
    if [ ${localDir:-} ]; then
        # generate fingerprint from all our dependencies
        echo -n 'local-'
        sha256sum <<< "$(build.dirChecksum "$localDir")" | cut -d' ' -f1

    elif [ $(basename "$(pwd)") = 'base_container' ]; then
        if [ -d "../container_build_framework" ]; then
            export CBF_VERSION=$(git.origin ../container_build_framework)
        elif [ "${CBF_VERSION:-}" ]; then
            :
        else
            die 'no version specified for CBF'
        fi
        echo "$CBF_VERSION"

    else
        # use parent's cbf.version
        docker inspect "$base" | jq -r '.[].Config.Labels."version.cbf"?'
    fi
}
export -f build.dependencyInfo

#----------------------------------------------------------------------------------------------
function build.dirChecksum()
{
    local -r dir=${1:?}

    # add any local 'build/container_build_framework' folder
    while read -r file; do
        sha256sum "$file"
    done < <(find "$dir" -type f -name '*' 2>/dev/null ||:)
}
export -f build.dirChecksum

#----------------------------------------------------------------------------------------------
function build.dockerCompose()
{
    local -r compose_yaml="${1:?}"

    local jsonConfig=$( build.yamlToJson "$compose_yaml" | jq '.services?' )
    if [ "${jsonConfig:-}" ]; then
        local -r service="$(jq -r 'keys[0]?' <<< "$jsonConfig")"
        [ -z "${service:-}" ] || jq $(eval echo "'.\"$service\"?'") <<< "$jsonConfig"
    fi
}
export -f build.dockerCompose

#----------------------------------------------------------------------------------------------
function build.findIdsWithFingerprint()
{
    local -r fingerprint=${1:?}

    curl --silent \
         --unix-socket /var/run/docker.sock http://localhost/images/json \
         | jq -r ".[]|select(.Labels.\"container.fingerprint\" == \"$fingerprint\").RepoTags[]?"
}
export -f build.findIdsWithFingerprint

#----------------------------------------------------------------------------------------------
function build.jsonParentChild()
{
    local os=${1:-}

    build.parentChild "$os" | jq '. as $data |
        def dependentsOf($f): [ $data[]|select(.parent == $f)|.image ];
        def parentsOf($f): [ $data[]|select(.image == $f)|.parent ];
        def composeTree: [ $data[].parent ] | unique | map( {"image":.,"parent": parentsOf(.) } );
        def dependentTree: [ $data[].image ] | unique | map( {"image":.,"dependents": dependentsOf(.) } );
        def rootImages: composeTree[]|select(.parent|length == 0)|.image;
        dependentTree'
}
export -f build.jsonParentChild

#----------------------------------------------------------------------------------------------
function build.logger()
{
    local msg=${1:?}

    if [ "${BUILD_URL:-}" ]; then
        if [[ $msg == checking* ]] || [[ $msg == *'has not changed.' ]]; then
            echo "    $msg" >&3
        else
            echo -e "    \e[32m$msg\e[0m" >&3
        fi
        echo "$msg" >> "$PROGRESS_LOG"
    fi
    echo "    $msg"
}
export -f build.logger

#----------------------------------------------------------------------------------------------
function build.logToKafka()
{
    if [ -z "${KAFKA_BOOTSTRAP_SERVERS:-}" ]; then
        echo 'KAFKA_BOOTSTRAP_SERVERS not defined. No metrics gathered'
        return 0
    fi

    local kafka_producer="$(which kafkaProducer.py 2>/dev/null ||:)"
    [ "$kafka_producer" ] || kafka_producer="$(dirname $(readlink -f "${BASH_SOURCE[0]}"))/kafkaProducer.py"
    if [ -z "${kafka_producer:-}" ] || [ ! -e "$kafka_producer" ]; then
        echo 'Unable to locate KAFKA_PRODUCER script. No metrics gathered'
        return 0
    fi

    local -r build_time=${1:-}
    local -r fingerprint=${2:-}
    local -r git_commit=${3:-}
    local -r git_url=${4:-}
    local -r origin=${5:-}
    local -r duration=${6:-}
    local -r elapsed=${7:-}
    local -r git_refs=${8:-}
    local -r status=${9:-}
    local -r containerOS=${10:-}

    local -a refs=( $git_refs )
    # create our data array that gets logged
    local -a build_data=( "$(json.encodeField "build_time" "$build_time")"
                          "$(json.encodeField "fingerprint" "$fingerprint")"
                          "$(json.encodeField "commit" "$git_commit")"
                          "$(json.encodeField "repo_url" "$git_url")"
                          "$(json.encodeField "origin" "$origin")"
                          "$(json.encodeField "duration" "$duration")"
                          "$(json.encodeField "elapsed" "$elapsed")"
                          "$(json.encodeArray "refs" $(json.arrayValues "${refs[@]}"))"
                          "$(json.encodeField "status" "$status")"
                          "$(json.encodeField "containerOS" "$containerOS")"
                        )
    if [ "${PROGRESS_LOG:-}" ] && [ -s "$PROGRESS_LOG" ]; then
        local -a progress_log=( $(< "$PROGRESS_LOG") )
        build_data+=("$(json.encodeArray "actions" $(json.arrayValues "${progress_log[@]}"))")
    fi


    # now log our data to kafka
    ("$kafka_producer" --server "$KAFKA_BOOTSTRAP_SERVERS"                     \
                      --topic 'container_build_data'                          \
                       --value "$( json.encodeHash '--' "${build_data[@]}" )") || :
    return 0
}
export -f build.logToKafka

#----------------------------------------------------------------------------------------------
function build.module()
{
    local -r containerOS=${1:?}

    local -i moduleStartTime=$(timer.getTimestamp)

    local compose_yaml="docker-compose.yml"
    [ -e "$compose_yaml" ] || return 0
    local config=$(build.dockerCompose "$compose_yaml")


    # setup environment for 'docker-compose build'
    export CONTAINER_BUILD_TIME=$(date +%Y%m%d-%H%M%S.%N -u)
    export CONTAINER_GIT_COMMIT="$(git.HEAD)"
    export CONTAINER_GIT_REFS="($(git.refs))"
    export CONTAINER_GIT_URL="$(git.remoteUrl)"
    export CONTAINER_ORIGIN="$(git.origin)"

    # generate fingerprint from all our dependencies
    local branch=$(git.branch)
    export BASE_TAG="${BASE_TAG:-${branch}-latest}"
    local -r dependencies="$(build.dependencyInfo "$config")"
    export CONTAINER_FINGERPRINT="$( sha256sum <<< "$dependencies" | cut -d' ' -f1 )"

    local taggedImage="$(eval echo $(jq '.image?' <<< $config))"
    taggedImage="${taggedImage%:*}:${BASE_TAG}"

    echo
    echo -n 'building '
    echo -en '\e[94m'
    echo -n "$taggedImage"
    echo -e '\e[0m'
    echo "    refs:           ${CONTAINER_GIT_REFS:-}"
    echo "    commitId:       ${CONTAINER_GIT_COMMIT:-}"
    echo "    repo:           ${CONTAINER_GIT_URL:-}"
    echo "    fingerprint:    ${CONTAINER_FINGERPRINT:-}"
    echo "    revision:       ${CONTAINER_ORIGIN:-}"

    [ "${CONTAINER_FINGERPRINT:-}" ] || trap.die "No base image found for '$taggedImage'. Unable to calculate fingerprint."

    local depLog="${containerOS}.dependencies.log"
    [ -e "$depLog" ] || touch "$depLog"
    if [ $(grep -c "$CONTAINER_FINGERPRINT" "$depLog") -eq 0 ]; then
        local offs=$(grep -n ' :: building ' "$depLog" | tail -2 | awk -F':' '{if(NR==1){print ($1-1)}}')
        [ -z "$offs" ] || [ $offs -le 0 ] || sed -i -e "1,$offs d" "$depLog"
        printf '%s :: building %s\n' "$(TZ='America/New_York' date)" "$taggedImage" >> "$depLog"
        echo "    refs:           ${CONTAINER_GIT_REFS:-}" >> "$depLog"
        echo "    commitId:       ${CONTAINER_GIT_COMMIT:-}" >> "$depLog"
        echo "    repo:           ${CONTAINER_GIT_URL:-}" >> "$depLog"
        echo "    fingerprint:    ${CONTAINER_FINGERPRINT:-}" >> "$depLog"
        echo "    revision:       ${CONTAINER_ORIGIN:-}" >> "$depLog"
        echo '  dependencies:' >> "$depLog"
        local -a deps=( $dependencies )
        printf '    %s\n' "${deps[@]}" >> "$depLog"
        printf '\n\n\n' >> "$depLog"
    fi


    # get name of image tagged with fingerprint
    export CONTAINER_TAG="$CONTAINER_FINGERPRINT"
    local actualImage="$(eval echo $(jq '.image?' <<< $config))"
    local -i status=0

    # rebuild container because no container exists with the correct fingerprint
    if [ "${BUILD_URL:-}" ]; then
        # this on Jenkins
        :> "$PROGRESS_LOG"
        local logBase="${logDir}/$dir"
        (build.updateContainer "$compose_yaml" "$taggedImage" "$actualImage" "$CONTAINER_ORIGIN" >"${logBase}.out" 2>"${logBase}.err") \
          && status=$? || status=$?
        [ $status -eq 9 ] && rm "${logBase}.out"

        # show location of log files if they have any content
        local log_display_base="${BUILD_URL}artifact/$logBase"
        [ -s "${logBase}.out" ] && echo "    STDOUT log:  ${log_display_base}.out/*view*/"
        [ -s "${logBase}.err" ] && echo "    STDERR log:  ${log_display_base}.err/*view*/"

        if [ $status -ne 0 ] && [ $status -ne 9 ]; then
          term.log "\n"
          term.log "***Error occurred while generating $taggedImage" 'error'
          echo
          echo '----------------------------------------------------------------------------------------------'
          echo
          echo  'STDOUT:'
          echo
          tail -30 ${logBase}.out
          echo
          echo '----------------------------------------------------------------------------------------------'
          echo
          echo  'STDERR:'
          echo
          tail -30 ${logBase}.err
          echo
          echo '----------------------------------------------------------------------------------------------'
        fi

    else
        (build.updateContainer "$compose_yaml" "$taggedImage" "$actualImage" "$CONTAINER_ORIGIN") && status=$? || status=$?
    fi
    local -i moduleEndTime=$(timer.getTimestamp)
    local -i moduleElapsed=$(( moduleEndTime - moduleStartTime ))
    local moduleDuration="$(timer.fmtElapsed $moduleElapsed)"
    printf '    duration:       %s\n' "$moduleDuration"

    build.logToKafka "$CONTAINER_BUILD_TIME" \
                     "$CONTAINER_FINGERPRINT" \
                     "$CONTAINER_GIT_COMMIT" \
                     "$CONTAINER_GIT_URL" \
                     "$CONTAINER_ORIGIN" \
                     "$moduleDuration" \
                     "$moduleElapsed" \
                     "$CONTAINER_GIT_REFS" \
                     "$status" \
                     "$containerOS"

    [ $status -eq 9 ] && status=0
    return $status
}
export -f build.module

#----------------------------------------------------------------------------------------------
function build.parentChild()
{
    local os=${1:-}

    local -i index=0
    local -r skip_builds_file='skip.build'
    echo '['
    while read -r dc_yaml; do
        [ -e "$skip_builds_file" ] && [ $(grep -cH "$(dirname "$dc_yaml")" "$skip_builds_file" 2>/dev/null | cut -d':' -f2) -eq 0 ] || continue
        local definedOS=$(grep -E '^#\s+containerOS:\s+' "$dc_yaml")
        [ "${definedOS:-}" ] && [ $(grep -cH "$os" <<< "$definedOS" | awk -F ':' '{print $2}') -eq 0 ] && continue

        (( index++ )) && echo -n ','
        eval echo $(build.yamlToJson "$dc_yaml" | jq '.services[]|{parent: .build.args.FROM_BASE, image: .image}?|tojson')

    done < <(find . -mindepth 2 -maxdepth 2 -name 'docker-compose.yml' | awk '{print substr($0,3)}')
    echo ']'
}
export -f build.parentChild

#----------------------------------------------------------------------------------------------
function build.pushImage()
{
    local -r tagged="${1:?}"
    local -r actual="${2:-}"

    local -r prefix='#\s+max\s+registry\s+entries:'
    local max_images=$(grep -E "$prefix" "$compose_yaml" | sed -r "s|${prefix}\s+(\d+)|\1|")
    : ${max_images:=$MAX_IMAGES_TO_KEEP}
    registry.pushImage "$max_images" "$tagged" "$actual"
}
export -f build.pushImage

#----------------------------------------------------------------------------------------------
function build.updateContainer()
{
    local -r compose_yaml=${1:?}
    local -r taggedImage=${2:?}
    local -r actualImage=${3:?}
    local -r revision=${4:-}

    if [ "${BUILD_ALWAYS:-0}" = 0 ]; then
        build.logger "checking for local $taggedImage with the correct fingerprint"
        local -a images
        mapfile -t images < <(build.findIdsWithFingerprint "$CONTAINER_FINGERPRINT" | grep -v '<none>:<none>' || :)
        if [ ${#images[*]} -gt 0 ]; then
            build.logger "${taggedImage} has not changed."
            local -i doPush=0
            if [ $(printf '%s\n' "${images[@]}" | grep "$taggedImage" | wc -l) -eq 0 ]; then
                # found image by a different 'name:tag'
                docker tag "${images[0]}" "$taggedImage"
                doPush=1
            elif [ "${BUILD_PUSH:-0}" != 0 ] || [ $(docker inspect "$taggedImage" | jq -r '.[].RepoDigests?|length') -eq 0 ]; then
                doPush=1
            fi
            [ $doPush -eq 0 ] || build.pushImage "$taggedImage"
            return 9
        fi


        # check if there is an image in the registry with the correct fingerprint
        build.logger "checking if $actualImage is available in registry"
        if docker pull "$actualImage" 2>/dev/null; then
            # downloaded image from registry
            build.changeImage "$taggedImage" "$actualImage"
            if [ "${BUILD_PUSH:-0}" != 0 ]; then
                build.logger "pushing ${taggedImage} to registry"
                build.pushImage "$taggedImage" "$actualImage"
            fi
            docker rmi "$actualImage"
            return 9
        fi
    fi

    # rebuild container because no container exists with the correct fingerprint
    build.logger "building $actualImage"
    docker-compose -f "$compose_yaml" build 2>&1 || trap.die "Build failure"

    build.changeImage "$taggedImage" "$actualImage"
    [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$taggedImage")" ] && docker tag "$actualImage" "$taggedImage"

    if build.canPush "$revision"; then
        build.logger "pushing ${taggedImage} to registry"
        build.pushImage "$taggedImage" "$actualImage"
    fi
    docker rmi "$actualImage"
    return 0
}
export -f build.updateContainer

#----------------------------------------------------------------------------------------------
function build.verifyModules()
{
    local -r containerOS=${1:?}
    shift
    local -a requestedModules=( "$@" )
    [ "${#requestedModules[*]}" -gt 0 ] || requestedModules=()
    local -r skip_builds_file='skip.build'

    local -a modules=( $(grep -Ev '^\s*#' "$(versions.DIRECTORY)/${containerOS}.modules") )
    for defMod in "${modules[@]}"; do
        [ -d "$defMod" ] && [ -e "${defMod}/docker-compose.yml" ] || continue
        [ -e "$skip_builds_file" ] && [ $(grep -cHE "^$defMod\s*$" "$skip_builds_file" 2>/dev/null | cut -d':' -f2) -gt 0 ] && continue

        local definedOS=$(grep -E '^#\s+containerOS:\s+' "${defMod}/docker-compose.yml" ||:)
        [ "${definedOS:-}" ] && [ $(grep -cH "$containerOS" <<< "$definedOS" | awk -F ':' '{print $2}') -eq 0 ] && continue

        if [ "${#requestedModules[*]}" -eq 0 ]; then
            echo "$defMod"
            continue
        fi

        for reqMod in "${requestedModules[@]}"; do
            [ "$reqMod" = "$defMod" ] || continue
            echo "$defMod"
        done
    done
}
export -f build.verifyModules

#----------------------------------------------------------------------------------------------
function build.wrapper()
{
    if [ -z "${BUILD_URL:-}" ]; then
        local logFile="$(pwd)/bld.log"
        echo 'build.all "$@" 2>&1 | tee '"$logFile"
        build.all "$@" 2>&1 | tee "$logFile" ||:
    else
        echo 'build.all "$@"'
        build.all "$@"
    fi
}
export -f build.wrapper

#----------------------------------------------------------------------------------------------
function build.yamlToJson()
{
    local -r yamlFile=${1:?}
    local -a YAML_TO_JSON=( 'python' '-c' 'import sys, yaml, json; json.dump(yaml.load(sys.stdin), sys.stdout, indent=4)' )

    if [ -e "$yamlFile"  ]; then
        "${YAML_TO_JSON[@]}" < "$yamlFile"

    elif [[ "$yamlFile" == http* ]]; then
        "${YAML_TO_JSON[@]}" <<< "$(curl --insecure --silent --request GET "$yamlFile")"

    else
        "${YAML_TO_JSON[@]}" <<< "$yamlFile"
    fi
}
export -f build.yamlToJson

#----------------------------------------------------------------------------------------------
