#!/bin/bash

declare -a YAML_TO_JSON=( 'python' '-c' 'import sys, yaml, json; json.dump(yaml.load(sys.stdin), sys.stdout, indent=4)' )
declare KAFKAPRODUCER="$(dirname $(readlink -f ${BASH_SOURCE[0]}))/kafkaProducer.py"
declare KAFKA_BOOTSTRAP_SERVERS="10.1.3.6:9092,10.1.3.10:9092,10.1.3.11:9092"
declare PROGRESS_LOG

#----------------------------------------------------------------------------------------------
function build.allContainers()
{
    local -a modules=( "$@" )

    # Use the Unofficial Bash Strict Mode
    set -o errexit
    set -o nounset
    set -o pipefail
    IFS=$'\n\t'

    set +o verbose
    set +o xtrace

    local start=$(timer.getTimestamp)
    [ -f ~/bin/trap.bashlib ] && source ~/bin/trap.bashlib

    export CFG_GITHUB_EMAIL=''
    export CFG_GITHUB_HUBOT_TOKEN=''
    export CFG_GITHUB_JENKINS_EMAIL=''
    export CFG_GITHUB_JENKINS_NAME=''
    export CFG_GITHUB_JENKINS_TOKEN=''
    export CFG_GITHUB_JENKINS_USER=''
    export CFG_GITHUB_NAME=''
    export CFG_GITHUB_TOKEN=''
    export CFG_GITHUB_USER=''
    export CFG_PASS=''
    export CFG_SLACK_HUBOT_TOKEN=''
    export CFG_USER=''
    export BASE_TAG=${BASE_TAG:-latest}
    export CONTAINER_OS="${CONTAINER_OS:-alpine/}"
    export DOCKER_REGISTRY=$(registry.SERVER)

    local logDir=logs
    [ -d "$logDir" ] || mkdir -p "$logDir"
    if [ "${BUILD_URL:-}" ]; then
        PROGRESS_LOG="$(readlink -f "$logDir")/progressInfo"
        touch "$PROGRESS_LOG"
    fi

    local build_time=$(date +%Y%m%d-%H%M%S.%N -u)
    local fingerprint="n/a"
    local git_commit=$(git rev-parse HEAD)
    local git_url="$(git remote get-url origin)"
    local origin=$(git describe --tags --dirty)
    local git_refs="$(git log -n1 --oneline --decorate | sed 's/[^\(]*(\([^\)]*\)).*/\1/')"

    echo
    echo "building $git_url"
    echo "    CONTAINER_OS:   ${CONTAINER_OS::-1}"
    echo "    refs:           (${git_refs})"
    echo "    commitId:       $git_commit"
    echo "    revision:       $origin"
    exec 3>&1  # create special stdout

    export CBF_VERSION=${CBF_VERSION:-master}
    local -i status=0
    for dir in "${modules[@]}"; do
        if [ -d "$dir" ]; then
            pushd "$dir" >/dev/null
            build.checkCBF "$dir"
            build.me && status=$? || status=$?
            popd >/dev/null
        else
            echo "invalid project directory: $dir"
        fi
        [ $status -eq 0 ] || break
    done
    exec 3>&-   # close special stdout
    # delete empty logs
    find "$logDir" -type f -size 0 -delete

    local finish=$(timer.getTimestamp)
    local -i elapsed=$(( finish - start ))

    echo
    echo
    TZ='America/New_York' date
    local duration="$(timer.fmtElapsed $elapsed)"
    printf 'Time elapsed: %s\n' "$duration"

    [ -z "${BUILD_URL:-}" ] || :> "$PROGRESS_LOG"
    build.logToKafka "$build_time" \
                     "$fingerprint" \
                     "$git_commit" \
                     "$git_url" \
                     "$origin" \
                     "$duration" \
                     "$elapsed" \
                     "$git_refs"

    return $status
}
export -f build.allContainers

#----------------------------------------------------------------------------------------------
function build.calculateFingerprint()
{
    local -r config=${1:?}

    # get the following
    #  - git tree hash
    #  - resolved 'docker build.args' config from docker-compose.yml
    #  - container digest of layer that we are building on top of
    #  - anything dirty in workspace


    # git tree hash
    local -a dependents
    mapfile -t dependents < <(git ls-tree HEAD -- . | awk '{print $3}')

    # resolve 'docker build.args' config from docker-compose.yml
    set +u
    dependents+=( "$(eval echo $(jq '.build.args?' <<< "$config"))"
                  "${CBF_VERSION:-}"
                )
    set -u

    # add any local 'build/container_build_framework' folder
    local -a files
    set +o pipefail
    mapfile -t files < <(find build/container_build_framework* -type f -name '*' 2>/dev/null | true)
    set -o pipefail
    if [ ${#files[*]} -gt 0 ]; then
        for file in "${files[@]}"; do
            dependents+=( "$(sha256sum "$file")" )
        done
    fi

    # container digest of layer that we are building on top of
    local base=$(eval echo $( jq '.build.args.FROM_BASE' <<< "$config" ))
    if [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$base")" ]; then
        echo pulling parent image: "$base" >&2
        [ "$(docker image ls "$base" | awk 'NR != 1')" ] || docker pull "$base" >&2 || return 0
    fi
    dependents+=( $(docker inspect "$base" | jq '.[].Id' ) )

    # anything dirty in workspace
    for line in $(git status --porcelain); do
        local file=$(awk '{print $2}' <<< "$line")
        case $(awk '{print $1}' <<< "$line") in
            A|M|MM)
                dependents+=( "$(sha256sum "$file")" );;
            *)
                dependents+=( "$line" );;
        esac
    done

    # generate fingerprint from all our dependents
    (sha256sum | cut -d' ' -f1) <<< "${dependents[*]}"
}
export -f build.calculateFingerprint

#----------------------------------------------------------------------------------------------
function build.checkCBF()
{
    local dir=${1:?}
    if [ "$dir" = base_container ]; then

        if [ -z "${CBF_VERSION:-}" ]; then
            [ -d "${TOP}/container_build_version" ] || die 'no version specified for CBF'
            # use existing CBF
            export CBF_VERSION=$(cd "${TOP}/container_build_version"; git describe --tags --dirty)
        fi
    else
        unset CBF_VERSION
    fi
}
export -f build.checkCBF

#----------------------------------------------------------------------------------------------
function build.changeImage()
{
    local taggedImage=${1:?}
    local actualImage=${2:?}

    [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}'  --filter "reference=$taggedImage")" ] || \
        [ "$(docker ps --format '{{.Image}}' | grep "$taggedImage")" ] || \
        docker rmi "$taggedImage"

    [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$actualImage")" ] || \
        docker tag "$actualImage" "$taggedImage"
}
export -f build.changeImage

#----------------------------------------------------------------------------------------------
function build.dockerCompose()
{
    local -r compose_yaml="${1:?}"

    local jsonConfig=$( "${YAML_TO_JSON[@]}" < "$compose_yaml" | jq '.services?')
    if [ "${jsonConfig:-}" ]; then
        local -r service="$(jq 'keys[0]?' <<< "$jsonConfig" | tr -d '"')"
        [ -z "${service:-}" ] || jq $(eval echo "'.\"$service\"?'") <<< "$jsonConfig"
    fi
}
export -f build.dockerCompose

#----------------------------------------------------------------------------------------------
function build.findIdsWithFingerprint()
{
    local -r fingerprint=${1:?}

    curl --silent \
         --unix-socket /var/run/docker.sock http://localhost/images/json \
         | jq ".[]|select(.Labels.\"container.fingerprint\" == \"$fingerprint\").Id" \
         | tr -d '"'
}
export -f build.findIdsWithFingerprint

#----------------------------------------------------------------------------------------------
function build.logger()
{
    local msg=${1:?}

    if [ "${BUILD_URL:-}" ]; then
        if [[ $msg == checking* ]] || [[ $msg == *'has not changed.' ]]; then
            echo "    $msg" >&3
        else
            echo -e "    \e[32m$msg\e[0m" >&3
        fi
        echo "$msg" >> "$PROGRESS_LOG"
    fi
    echo "    $msg"
}
export -f build.logger

#----------------------------------------------------------------------------------------------
function build.logToKafka()
{
    local -r build_time=${1:-}
    local -r fingerprint=${2:-}
    local -r git_commit=${3:-}
    local -r git_url=${4:-}
    local -r origin=${5:-}
    local -r duration=${6:-}
    local -r elapsed=${7:-}
    local -r git_refs=${8:-}

    local -a refs=( $git_refs )
    # create our data array that gets logged
    local -a build_data=( "$(json.encodeField "build_time" "$build_time")"
                          "$(json.encodeField "fingerprint" "$fingerprint")"
                          "$(json.encodeField "commit" "$git_commit")"
                          "$(json.encodeField "repo_url" "$git_url")"
                          "$(json.encodeField "origin" "$origin")"
                          "$(json.encodeField "duration" "$duration")"
                          "$(json.encodeField "elapsed" "$elapsed")"
                          "$(json.encodeArray "refs" $(json.arrayValues "${refs[@]}"))"
                        )
    if [ "${PROGRESS_LOG:-}" ] && [ -s "$PROGRESS_LOG" ]; then
        local -a progress_log=( $(< "$PROGRESS_LOG") )
        build_data+=("$(json.encodeArray "actions" $(json.arrayValues "${progress_log[@]}"))")
    fi

    # now log our data to kafka
    "${KAFKAPRODUCER}" --server "$KAFKA_BOOTSTRAP_SERVERS"                        \
                          --topic 'container_build_data'                          \
                          --value "$( json.encodeHash '--' "${build_data[@]}" )"
    return 0
}
export -f build.logToKafka

#----------------------------------------------------------------------------------------------
function build.me()
{
    local -i startTime=$(timer.getTimestamp)

    local compose_yaml="docker-compose.${CONTAINER_OS::-1}.yml"
    [ -e "$compose_yaml" ] || compose_yaml=docker-compose.yml
    local config=$(build.dockerCompose "$compose_yaml")

    local taggedImage="$(eval echo $(jq '.image?' <<< $config))"
    taggedImage="${taggedImage%:*}:${BASE_TAG}"

    # setup environment for 'docker-compose build'
    export CONTAINER_BUILD_TIME=$(date +%Y%m%d-%H%M%S.%N -u)
    export CONTAINER_FINGERPRINT="$(build.calculateFingerprint "$config")"
    export CONTAINER_GIT_REFS="($(git log -n1 --oneline --decorate | sed 's/[^\(]*(\([^\)]*\)).*/\1/'))"
    export CONTAINER_GIT_COMMIT="$(git rev-parse HEAD)"
    export CONTAINER_GIT_URL="$(git remote get-url origin)"
    export CONTAINER_ORIGIN="$(git describe --tags --dirty)"

    echo
    echo -n 'building '
    echo -en '\e[34m'
    echo -n "$taggedImage"
    echo -e '\e[0m'
    echo "    refs:           ${CONTAINER_GIT_REFS:-}"
    echo "    commitId:       ${CONTAINER_GIT_COMMIT:-}"
    echo "    repo:           ${CONTAINER_GIT_URL:-}"
    echo "    fingerprint:    ${CONTAINER_FINGERPRINT:-}"
    echo "    revision:       ${CONTAINER_ORIGIN:-}"

    [ "${CONTAINER_FINGERPRINT:-}" ] || trap.die "No base image found for '$taggedImage'. Unable to calulate fingerprint."


    # get name of image tagged with fingerprint
    export CONTAINER_TAG="$CONTAINER_FINGERPRINT"
    local actualImage="$(eval echo $(jq '.image?' <<< $config))"
    local -i status=0

    # rebuild container because no container exists with the correct fingerprint
    if [ "${BUILD_URL:-}" ]; then
        # this on Jenkins
        :> "$PROGRESS_LOG"
        local logBase="${logDir}/$dir"
        (build.updateContainer "$compose_yaml" "$taggedImage" "$actualImage" "$CONTAINER_ORIGIN" >"../${logBase}.out" 2>"../${logBase}.err") \
          && status=$? || status=$?
        if [ $status -eq 9 ]; then
            status=0
            rm "../${logBase}.out"
        fi

        # show location of log files if they have any content
        local log_display_base="${BUILD_URL}artifact/$logBase"
        [ -s "../${logBase}.out" ] && echo "    STDOUT log:  ${log_display_base}.out/*view*/"
        [ -s "../${logBase}.err" ] && echo "    STDERR log:  ${log_display_base}.err/*view*/"

        if [ $status -ne 0 ]; then
          term.log "\n"
          term.log "***Error occurred while generating $taggedImage" 'error'
          echo
          echo '----------------------------------------------------------------------------------------------'
          echo
          echo  'STDOUT:'
          echo
          cat ../${logBase}.out
          echo
          echo '----------------------------------------------------------------------------------------------'
          echo
          echo  'STDERR:'
          echo
          cat ../${logBase}.err
          echo
          echo '----------------------------------------------------------------------------------------------'
        fi

    else
        (build.updateContainer "$compose_yaml" "$taggedImage" "$actualImage" "$CONTAINER_ORIGIN") && status=$? || status=$?
        [ $status -eq 9 ] && status=0
    fi
    local -i endTime=$(timer.getTimestamp)
    local -i elapsed=$(( endTime - startTime ))
    local duration="$(timer.fmtElapsed $elapsed)"
    printf '    duration:       %s\n' "$duration"
    build.logToKafka "$CONTAINER_BUILD_TIME" \
                     "$CONTAINER_FINGERPRINT" \
                     "$CONTAINER_GIT_COMMIT" \
                     "$CONTAINER_GIT_URL" \
                     "$CONTAINER_ORIGIN" \
                     "$duration" \
                     "$elapsed" \
                     "$CONTAINER_GIT_REFS"
    return $status
}
export -f build.me

#----------------------------------------------------------------------------------------------
function build.updateContainer()
{
    local -r compose_yaml=${1:?}
    local -r taggedImage=${2:?}
    local -r actualImage=${3:?}
    local -r revision=${4:-}

    if [ -z "${ALWAYS_BUILD:-}" ]; then
        build.logger "checking for local $taggedImage with the correct fingerprint"
        local -a images
        mapfile -t images < <(build.findIdsWithFingerprint "$CONTAINER_FINGERPRINT")
        if [ ${#images[*]} -gt 0 ]; then
            build.logger "${taggedImage} has not changed."
            [ -z "${DOCKER_ALWAYS_PUSH:-}" ]  ||  registry.push "$taggedImage"
            return 9
        fi

        # check if there is an image in the registry with the correct fingerprint
        build.logger "checking if $actualImage is available in registry"
        if docker pull "$actualImage" 2>/dev/null; then
            # downloaded image from registry
            build.changeImage "$taggedImage" "$actualImage"
            if [ "${DOCKER_ALWAYS_PUSH:-}" ]; then
                build.logger "pushing ${taggedImage} to registry"
                registry.push "$taggedImage" "$actualImage"
            fi
            docker rmi "$actualImage"
            return 9
        fi
    fi

    # rebuild container because no container exists with the correct fingerprint
    build.logger "building $actualImage"
    docker-compose -f "$compose_yaml" build 2>&1 || trap.die "Build failure"


    build.changeImage "$taggedImage" "$actualImage"
    [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$taggedImage")" ] && docker tag "$actualImage" "$taggedImage"

    if registry.canPush "$revision"; then
        build.logger "pushing ${taggedImage} to registry"
        registry.push "$taggedImage" "$actualImage"
    fi
    docker rmi "$actualImage"
    return 0
}
export -f build.updateContainer

#----------------------------------------------------------------------------------------------
function build.yamlToJson()
{
    local -r yamlFile=${1:?}
    if [ -e "$yamlFile"  ]; then
        "${YAML_TO_JSON[@]}" < "$yamlFile"

    elif [[ "$yamlFile" == http* ]]; then
        "${YAML_TO_JSON[@]}" <<< "$(curl --insecure --silent --request GET "$yamlFile")"

    else
        "${YAML_TO_JSON[@]}" <<< "$yamlFile"
    fi
}
export -f build.yamlToJson
