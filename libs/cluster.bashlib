#!/bin/bash

#############################################################################
#
#   cluster.bashlib; basic functions to run a cluster environment
#
#############################################################################


#----------------------------------------------------------------------------------------------
function cluster.__initGlobals()
{
    local -r base_dir=${1:?}

    export START_TIME=$(date)

    [ -e "${base_dir}/.git" ] || trap.die "invalid base directory specified"


    # setup environment

    export CONFIG_DIR="${base_dir}/config"
    readonly CONFIG_DIR


    # verify our basic setup is good
    [ -f "${CONFIG_DIR}/container.os" ] || trap.die "missing 'container.os' file"
    export CONTAINER_OS="$(< "${CONFIG_DIR}/container.os")"
    readonly CONTAINER_OS

    export VERSIONS_FILE="${base_dir}/versions/$CONTAINER_OS"
    readonly VERSIONS_FILE

    export WORKSPACE_DIR="${base_dir}/workspace"
    readonly WORKSPACE_DIR
    [ -d "$WORKSPACE_DIR" ] || cluster.showInitializationBanner


    export LOG_DIR="${base_dir}/logs"
    readonly LOG_DIR

    export SECRETS_DIR="${WORKSPACE_DIR}/.secrets"
    readonly SECRETS_DIR

#    export CONTAINER_TAG=${CONTAINER_TAG:-latest}
#    readonly CONTAINER_TAG

    export CFG_USER
    : ${CFG_USER:=$(git config --get adsk.github.account 2>/dev/null || :)}
    : ${CFG_USER:=${USERNAME:-}}
    : ${CFG_USER:=${USER:-}}
    readonly CFG_USER

    export CFG_GITHUB_EMAIL="$(git config --get user.email)"
    readonly CFG_GITHUB_EMAIL

    export CFG_GITHUB_NAME="$(git config --get user.name)"
    readonly CFG_GITHUB_NAME

    export CFG_EMAIL="${CFG_EMAIL:-$CFG_GITHUB_EMAIL}"
    readonly CFG_EMAIL
}
export -f cluster.__initGlobals

#----------------------------------------------------------------------------------------------
function cluster.clean()
{
    local -r workspace=${1:?}
    local -r yaml="${workspace}/docker-compose.yml"

    if [ -f "$yaml" ]; then
 #       local -r repo="$(git remote get-url origin)"
 #       local -r branch="$(git branch | grep '*' | awk '{print $2}')"

        echo -en '\n\e[97m'
        echo -n 'INFO: bringing down containers to allow 'workspace' to be cleaned'
        echo -e '\e[0m'
        echo "\$ docker-compose down"
        CFG_GITHUB_EMAIL=.. CFG_GITHUB_NAME=.. CFG_USER=.. CFG_EMAIL=.. docker-compose --file "$yaml" down ||:
    fi
    echo "\$ rm -rf $workspace"
    find "$workspace" -mindepth 1 -maxdepth 1 ! -name '.secrets' -exec sudo rm -rf '{}' \;
}
export -f cluster.clean

#----------------------------------------------------------------------------------------------
function cluster.generateSSL()
{
    local -r secretDir=${1:?}

    mkdir -p "$secretDir" ||:
    pushd "$secretDir" >/dev/null
    if [ ! -e dhparam.pem ] || [ ! -e server.key ] || [ ! -e server.crt ] || [ ! -e server.csr ]; then

        echo -en '\e[95m'
        echo -n '>> GENERATING SSL CERT'
        echo -e '\e[0m'
        openssl genrsa -des3 -passout pass:x -out server.pass.key 2048
        openssl rsa -passin pass:x -in server.pass.key -out server.key
        rm server.pass.key

        openssl dhparam -out dhparam.pem 2048
        openssl req -new -key server.key -out server.csr -subj "/C=US/ST=Massachusetts/L=Hopkinton/O=DELL_EMC/OU=com/OU=docker.nginx.io/CN=$(hostname -s)"
        openssl x509 -req -sha256 -days 300065 -in server.csr -signkey server.key -out server.crt
        echo -en '\e[95m'
        echo -n '>> GENERATING SSL CERT ... DONE'
        echo -e '\e[0m'
    fi
    popd >/dev/null
}
export -f cluster.generateSSL

#----------------------------------------------------------------------------------------------
# setup workspace if it does not exist
function cluster.initializeWorkspace()
{
    [ $# -eq 0 ] || cluster.__initGlobals "$1"

    mkdir -p "$WORKSPACE_DIR" ||:
    cd "$WORKSPACE_DIR"


    # import our setup configuration
    local -r setup_config="${CONFIG_DIR}/setup.cfg"
    if [ -e "$setup_config" ]; then
        while read -r line; do
            eval "export $line"
        done < <(cat "$setup_config")
    fi

    : ${KAFKA_BROKER_ID:?"KAFKA_BROKER_ID has not been configured. Please update '$setup_config'"}
    : ${GRAFANA_UID:?"GRAFANA_UID has not been configured. Please update '$setup_config'"}


    # ensure our log dir exists
    [ -d "$LOG_DIR" ] || mkdir -p "$LOG_DIR" ||:


    # copy docker-compose.yml to workspace
    local -r yaml="${WORKSPACE_DIR}/docker-compose.yml"
    [ -e "$yaml" ] || cluster.updateDockerComposeYaml "$yaml"


    local -ri num_secrets=$(docker.yamlToJson "$yaml" | jq '.services[]|select(has("secrets"))|.secrets[]' | wc -l)
    [ "$num_secrets" -eq 0 ] || [ -d "$SECRETS_DIR" ] || cluster.populateSecrets "$SECRETS_DIR"


    # create the folders which are mounted by containers (defined in docker-compose volumes)
    local -A service_tasks=()
    while read -r dir; do

        [ "${dir:0:2}" = './' ] && dir="${dir:2}"                        # remove './' prefix
        local service_name="$(awk -F '/' '{print $1}' <<< "$dir")"       # extract folder used for service

        # look for individual service tasks (to run later)
        if [ ! -d "$service_name" ]; then
            local initFunction="${CONFIG_DIR}/${service_name}.setup"
            [ -e  "$initFunction" ] && service_tasks["$service_name"]="$initFunction"
        fi

        # initialize dir when needed
        if [ ! -d "$dir" ]; then
            sudo mkdir -p "$dir" ||:
            sudo chown "$USER" "$dir"
        fi

        # ensure log symlinks are setup
        if [ "$dir" = "${service_name}/log" ] && [ "$(readlink "${LOG_DIR}/$service_name")" != "${WORKSPACE_DIR}/$dir" ]; then
            # get rid of any old stuff that may prevent us creating symlink
            [ -f "${LOG_DIR}/$service_name" ] && sudo rm "${LOG_DIR}/$service_name"
            [ -h "${LOG_DIR}/$service_name" ] && sudo rm "${LOG_DIR}/$service_name"
            ln -s "${WORKSPACE_DIR}/$dir" "${LOG_DIR}/$service_name"
        fi

    done < <(docker.yamlToJson "$yaml" \
             | jq '.services[].volumes[]?' \
             | tr -d '"' \
             | awk -F ':' '{print $1}' \
             | grep -v '/docker' \
             | grep -Ev '^~' \
             | sort -u)


    # now run our service tasks
    for task in $(printf '%s\n' "${!service_tasks[@]}" | sort); do
        chmod 755 "${service_tasks[$task]}"
        "${service_tasks[$task]}" ||:
    done
}
export -f cluster.initializeWorkspace

#----------------------------------------------------------------------------------------------
function cluster.main()
{
    local -r base=${1:?} ; shift
    local -ra args=( "$@" )

    # Parse command-line options into above variable
    local -r progname="$( basename "${BASH_SOURCE[0]}" )"
    local -r longopts='help,Help,HELP,clean,init'
    local -r shortopts='Hhci'
    local -r options=$(getopt --longoptions "${longopts}" --options "${shortopts}" --name "$progname" -- ${args[@]}) || cluster.usage $?
    eval set -- "$options"

    local doClean doInit
    while true; do
        case "$1" in
            -h|--h|-H|--H|--help|-help|--HELP|-HELP|--Help|-Help)          cluster.usage 0;;
            -c|--c|--clean)                                                doClean=1; shift 2;;
            -i|--i|--init)                                                 doInit=1; shift 2;;
            --) shift; break ;;
            *) echo "$1"; echo "Internal argument parsing error";    cluster.usage;;
        esac
    done

    mkdir -p "$workspace" ||:

    [ -z "${doClean:-}" ] || cluster.clean "$workspace"
    if [ "${doInit:-}" ]; then
        #  initialize devops_container_environment
        echo
        echo '$ cluster.initializeWorkspace 2>&1 | tee setup.log'
        cluster.initializeWorkspace "$base" 2>&1 | tee  "${workspace}/setup.log"
        exit 0
    fi

    #  restart devops_container_environment  (performs configuration if needed)
    echo
    echo '$ cluster.restartCluster 2>&1 | tee restart.log'
    cluster.restartCluster "$base" 2>&1 | tee  "${workspace}/restart.log"
}
export -f cluster.main

#----------------------------------------------------------------------------------------------
function cluster.populateSecrets()
{
    local -r secrets_dir=${1:-}

    echo 'populating secrets'
    if [ -z "${CFG_USER_SECRETS:-}" ]  &&  [ "${OPEN_SECRETS_REPO:-}" ]; then
        mkdir -p "$(dirname "$secrets_dir")"
        git clone "$OPEN_SECRETS_REPO" "$secrets_dir"

    elif [ -d "${CFG_USER_SECRETS:-}" ] &&  [ "$(readlink -f "$CFG_USER_SECRETS")" != "$(readlink -f "$secrets_dir")" ]; then
        mkdir -p "$secrets_dir"
        cp "${CFG_USER_SECRETS}"/* "$secrets_dir"/

    elif git ls-remote "${CFG_USER_SECRETS:-}" &> /dev/null ; then
        mkdir -p "$(dirname "$secrets_dir")"
        git clone "$CFG_USER_SECRETS" "$secrets_dir"

    else
        trap.die  "missing 'secrets' directory in workspace"
    fi


    # ensure we have self signed certs (incase they are not include in secrets dir
    cluster.generateSSL "$secrets_dir"
}
export -f cluster.populateSecrets

#----------------------------------------------------------------------------------------------
function cluster.replaceIpAddresses()
{
    local -r filename=${1:?}
    local -r host_ip=${2:?}

    if [ -e "$filename" ]; then
        local -r ip_match_rgx='((1?[0-9][0-9]?|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9][0-9]?|2[0-4][0-9]|25[0-5])'
        local expr="'s#${ip_match_rgx}#${host_ip}#g'"
        eval sed -i -r -e "$expr" "$filename"
    fi
}
export -f cluster.replaceIpAddresses

#----------------------------------------------------------------------------------------------
function cluster.restartCluster()
{
    local -r base_dir=${1:-}
    [ $# -eq 0 ] || cluster.__initGlobals "$base_dir"


    # make sure we have the latest versions
    cluster.updateVersions "$VERSIONS_FILE" "${CONTAINER_TAG:-}"


    # initialize workspace if required 'docker-compose.yml' is missing
    local dc_yaml="${WORKSPACE_DIR}/docker-compose.yml"
    [ -f "$dc_yaml" ] || cluster.initializeWorkspace


    # restart our environment
    cluster.restartContainers "$dc_yaml"

    local -r run_log="${WORKSPACE_DIR}/run.log"
    cluster.waitForInitializationComplete "$dc_yaml" "$run_log"

    docker.showProcessReport
    echo

    if [ "${INITIALIZATION:-}" ]; then
        echo -en '\e[97m'
        echo -n "Initializing complete. Please open the following URL in your browser: http://$(environ.ipAddress)"
        echo -e '\e[0m'
    fi
    exit 0
}
export -f cluster.restartCluster

#----------------------------------------------------------------------------------------------
function cluster.restartContainers()
{
    local -r dc_yaml=${1:?}

    # stop any running containers
    echo " docker-compose --file $dc_yaml down"
    docker-compose --file "$dc_yaml" down
    set -o verbose
    sudo find -L "$LOG_DIR" -type f ! -name '.*' -delete
    set +o verbose

    cluster.updateContainers "$dc_yaml" "${CONTAINER_TAG:-}"

    echo -en '\e[97m'
    echo -n 'INFO: bringing up containers'
    echo -e '\e[0m'
    echo " docker-compose --file $dc_yaml up --detach"
    docker-compose --file "$dc_yaml" up -d   # docker-compose v1.17.0 does not like '--detach'!
}
export -f cluster.restartContainers

#----------------------------------------------------------------------------------------------
function cluster.showInitializationBanner()
{
    echo -e '\e[97m'
    echo '******************************************************************************'
    echo '*                                                                            *'
    echo "*  initializing DevOps Container Environment on $(environ.ipAddress)"
    echo '*                                                                            *'
    echo '******************************************************************************'
    echo -e '\e[0m'
    export INITIALIZATION='true'
}

#----------------------------------------------------------------------------------------------
function cluster.updateContainers()
{
    local -r dc_yaml=${1:?}
    local -r container_tag=${2:-}

    # make sure we start the correct versions
    echo -en '\n\e[97m'
    if [ "${container_tag:-}" ]; then
        echo -n "INFO: updating containers to $container_tag"
    else
        echo -n 'INFO: refreshing containers'
    fi
    echo -e '\e[0m'
    echo " docker-compose --file $dc_yaml pull"
    docker-compose --file "$dc_yaml" pull
    docker.rmOldContainers

    # fixup docker-compose.yml to reflext the versions in use
}
export -f cluster.updateContainers

#----------------------------------------------------------------------------------------------
function cluster.updateDockerComposeYaml()
{
    local -r yaml=${1:?}
    local -r id="${2:-$KAFKA_BROKER_ID}"
    local -r grafana_uid="${3:-$GRAFANA_UID}"

    local -r host_ip="$(environ.ipAddress)"
    local -r this_host="$(environ.shortName)"


    cp "${CONFIG_DIR}/skip.wait" "${WORKSPACE_DIR}/skip.wait"


    # make a copy of file in 'config' dir
    local -r deploy_yaml="${CONFIG_DIR}/docker-compose.yml"
    [ -f "$deploy_yaml" ] || trap.die "Invalid configuration - no $deploy_yaml"

    # update copy of docker-compose
    grep -vE '^\s*#' "$deploy_yaml" > "$yaml"
    for line in $(grep -E "^\s*(.*=[^#]+)\s*" "$VERSIONS_FILE" | sed -r -e 's|^\s*(.*=[^#]+)\s*|\1|'); do
        line=$(eval "echo '$line'")
        var="${line%=*}"
        val="${line##*=}"
        eval sed -i -r -e "'s|(\\\$\{${var}:-)[^\}]+\}|\1${val}\}|g'" "$yaml"
    done
    sed -i -r -e "s|255\.255\.255\.255|${host_ip}|" \
              -e "s|(KAFKA_BROKER_ID: ).*\$|\1${id}|" \
              -e "s|user:\s+\"?1000\"?|user: \"${grafana_uid}\"|" \
             "$yaml"
}
export -f cluster.updateDockerComposeYaml

#----------------------------------------------------------------------------------------------
function cluster.updateRelease()
{
    local -r yaml=${1:?}

    local -r json=$(docker.yamlToJson "$yaml")
    local service
    while read -r line; do
        [ $(grep -EcH '^\s+image:\s+.*CONTAINER_TAG' <<< "$line" | awk -F ':' '{print $2}') -gt 0 ] || continue
        local releaseVersion=$(docker.containerVersion "$line" "$json")
        eval sed -i -e "'s|$line|$releaseVersion|'" "'$yaml'"
    done < <(cat "$yaml")
}
export -f cluster.updateDockerComposeYaml

#----------------------------------------------------------------------------------------------
function cluster.updateVersions()
{
    local -r versions_file=${1:?}
    local -r branch=${2:-}

    local -r versions_dir="$(dirname "$versions_file")"
    local -r containerOS="$(basename "$versions_file")"

    [ -d "$versions_dir" ] || trap.die 'no version information available'

    local -a vfiles=()
    mapfile -t vfiles < <(ls -1A "$versions_dir")
    [ "${#vfiles[*]}" -eq 0 ] && git submodule update --init --remote

    # ensure version info is up-to-date
    [ -z "${branch:-}" ] || ( cd "$versions_dir"; git checkout "$branch"; git pull )
    [ -e "$versions_file" ] || trap.die "Unrecognized CONTAINER_OS: $containerOS"
    source "$versions_file"
}
export -f cluster.updateVersions

#----------------------------------------------------------------------------------------------
function cluster.usage()
{
    local -i exit_status=${1:-1}

    cat >&2 << EOF
Usage:
    $progname [ -h|--help ] | [ --clean ] | [ --init ]

    Common options:
        -h --help              Display a basic set of usage instructions
        -c --clean             0:do not clean environment
                               1:clean environment before build (default)
        -i --init              only initialize the environment
EOF
    exit "$exit_status"
}

#----------------------------------------------------------------------------------------------
function cluster.waitForInitializationComplete()
{
    local -r dc_yaml=${1:?}
    local -r run_log=${2:?}

    # get the list of containers we will be checking
    local -a containers
    mapfile -t containers < <(docker.services "$dc_yaml")


    # initialize the log
    echo "Started at: ${START_TIME}" > "$run_log"

    local -A finished=( )
    local -a lines=()
    local container line
    local -i index=1

    echo -en '\n\e[97m'
    echo -n "INFO: waiting for ${#containers[*]} containers to complete their startup"
    echo -e '\e[0m'
    while [ ${#finished[*]} -lt ${#containers[*]} ]; do
        sleep 5
        lines=()
        for container in "${containers[@]}"; do
            if grep "$container" "${WORKSPACE_DIR}/skip.wait" >/dev/null &&  [ -z "${finished[${container,,}]:-}" ]; then
                printf '%02d. %s: skipping wait.\n' $(( index++ )) "${container^^}"
                finished[$container]='0'
            fi

            local text="$(docker logs "${container,,}" 2>&1 | grep -s "Finished executing startup" | head -1 ||: )"
            [ "$text" ] || continue                                        # ignore blank lines
            [ "${container,,}" ] || continue                               # ignore invalid container
            [ -z "${finished[${container,,}]:-}" ] || continue             # ignore if we already have this result

            finished[${container,,}]="$text"
            lines+=( "$(sed -Ee 's|^.+Finished executing startup scripts after ||' <<< "$text" | awk -F ':' '{ print ((($1 * 60) + $2) * 60) + $3 }')_${container,,}" )
        done
        [ ${#lines[*]} -gt 0 ] || continue

        for line in $(printf '%s\n' "${lines[@]}" | sort -t '_' -k 1n,2); do   # sort by time taken to finish startup
            container="${line##*_}"                                            # extract container name
            container="${container,,}"
            printf '%02d. %s\n' $(( index++ )) "${finished[${container}]:-}"
            docker logs "${container}" >> "$run_log" 2>&1                      # grab the log
        done
    done

    for container in "${containers[@]}"; do
        if grep "$container" "${WORKSPACE_DIR}/skip.wait" >/dev/null ; then
            echo >> "$run_log" 2>&1
            echo '>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>' >> "$run_log" 2>&1
            echo "${container}" >> "$run_log" 2>&1
            echo >> "$run_log" 2>&1
            docker logs "${container}" >> "$run_log" 2>&1                      # grab the log
        fi
    done
}
export -f cluster.waitForInitializationComplete

#----------------------------------------------------------------------------------------------
