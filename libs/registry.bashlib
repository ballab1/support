#!/bin/bash

#"No HTTP secret provided - generated random secret. This may cause problems with uploads
#"redis not configured"
#"using inmemory blob descriptor cache"

#----------------------------------------------------------------------------------------------
function registry.DELETE()
{
    registry.io --request DELETE "$@"
}

#----------------------------------------------------------------------------------------------
function registry.GET()
{
    registry.io --request GET "$@"
}

#----------------------------------------------------------------------------------------------
function registry.POST()
{
    registry.io --request POST "$@"
}

#----------------------------------------------------------------------------------------------
function registry.PUT()
{
    registry.io --request PUST "$@"
}

#----------------------------------------------------------------------------------------------
function registry.SERVER()
{
    echo "${_REGISTRY_SERVER:=$(lib.getProperty "${FUNCNAME[0]##*.}" "$( registry.propertiesFile )")}"
}

#----------------------------------------------------------------------------------------------
function registry.URL()
{
    echo "${_REGISTRY_URL:=$(lib.getProperty "${FUNCNAME[0]##*.}" "$( registry.propertiesFile )")}"
}

#----------------------------------------------------------------------------------------------
function registry.USER()
{
    echo "${_REGISTRY_USER:=$(lib.getProperty "${FUNCNAME[0]##*.}" "$( registry.propertiesFile )")}"
}

#----------------------------------------------------------------------------------------------
function registry.propFile()
{
    echo "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")/properties/$(basename "${BASH_SOURCE[0]%.*}").properties"
}

export REGISTRY_PROPERTIES_FILE="${REGISTRY_PROPERTIES_FILE:=$(registry.propFile)}"

#----------------------------------------------------------------------------------------------
function registry.canPush()
{
    local -r revision=${1:?}

    [ "${DOCKER_ALWAYS_PUSH:-}" ] && return 0
    [[ "$revision" != *dirty ]] || return 1

#    [ "$CONTAINER_GIT_REFS" = 'master' ]

    return 0
}
export -f registry.canPush

#----------------------------------------------------------------------------------------------
function registry.catalog()
{
    local -a entries=()
    registry.GET --silent "$(registry.URL)/_catalog" | jq '.repositories| sort[]? ' | tr -d '"'
}
export -f registry.catalog

#----------------------------------------------------------------------------------------------
function registry.credentials()
{
    local -r user=${1:-"${USERNAME:-$USER}"}

#    echo "$user:$(lib.getProperty "$user" "$( registry.propertiesFile )")"
}
export -f registry.credentials

#----------------------------------------------------------------------------------------------
function registry.createTime()
{
    local -r name=${1:?}
    local -r tag=${2:?}

    local -r manifests="$(registry.manifest "$name" "$tag" )"
    if [ -z "$manifests" ] || [[ $manifests =~ MANIFEST_INVALID ]]; then
        echo '                      '
    else
        (jq '[ .history[].v1Compatibility|fromjson.created | sub("\\.\\d+Z"; "Z") | fromdate] | max | todate' ) <<< "$manifests"
    fi
}
export -f registry.createTime

#----------------------------------------------------------------------------------------------
function registry.deleteImage()
{
    local -r id=${1:?}

    local -r name="${id%:*}"
    local -r tag="${id##*:}"
    [ "${name:-}" ] && [ "${tag:-}" ] || trap.die "Invalid $id specified"

    local -r digest="$(registry.digest "$name" "$tag")"
    [ -z "${digest}" ] || registry.DELETE --show-error --write-out '\n%{http_code}\n' --verbose "$(registry.URL)/${name}/manifests/${digest}"
}
export -f registry.deleteImage

#----------------------------------------------------------------------------------------------
function registry.digest()
{
    local -r name=${1:?}
    local -r tag=${2:?}

    local -r digest="$(registry.GET --header "Accept: application/vnd.docker.distribution.manifest.v2+json" \
                                    --silent \
                                    --head \
                                    "$(registry.URL)/${name}/manifests/${tag}" )"

    [ -z "$digest" ] || ( awk '{gsub(/\r/,"");if ($1 == "Docker-Content-Digest:") {print $2}}') <<< "$digest"
}
export -f registry.digest

#----------------------------------------------------------------------------------------------
function registry.io()
{
    local -r response=$(curl --insecure "$@")
#         --user "$(registry.credentials "$(registry.USER)")" \
#    local status=$?
#    if [ $status -eq 0 ]; then
    if [[ "$response" != '{"errors":['* ]]; then
        echo "$response"
        return 0
    fi

    # an error occurred
    local -r errors="$(jq '.errors[]' <<< "$response")"

    local curl_cmd=( 'curl' '--insecure' "${@}" )
    local -a vals=()
    for val in "${curl_cmd[@]}"; do
        vals+=( "$(echo $val | sed -Ee 's/[\r\n]//g' -Ee 's/^\s+(\w)/\1/' -Ee 's/(\w)\s+$/\1/')" )
    done

    echo
    term.log "***ERROR: failure to complete registry request
    command:       $(printf '%s ' "${vals[@]}")
    error code:    $(jq '.code' <<< "$errors")
    error message: $(jq '.message' <<< "$errors")
    error details: $(jq '.detail' <<< "$errors")
    " 'warn' >&2

    return 1
}

#----------------------------------------------------------------------------------------------
function registry.layer()
{
    local -r name=${1:?}
    local -r digest=${2:?}

    registry.GET --silent "$(registry.URL)/${name}/blobs/${digest}"
}
export -f registry.layer

#----------------------------------------------------------------------------------------------
function registry.manifest()
{
    local -r name=${1:?}
    local -r reference=${2:?}

    registry.GET --silent "$(registry.URL)/${name}/manifests/${reference}"
}
export -f registry.manifest

#----------------------------------------------------------------------------------------------
function registry.propertiesFile()
{
    echo "${REGISTRY_PROPERTIES_FILE:=$(registry.propFile)}"
}
export -f registry.propertiesFile

#----------------------------------------------------------------------------------------------
function registry.push()
{
    local -ra images=( "$@" )
    [ ${#images[*]} -eq 0 ] && return 1

    local -a allImages=()
    for image in "${images[@]}"; do
        allImages+=( "$image" )
        local fp="$(docker inspect "$image" | jq '.[].Config.Labels."container.fingerprint"?' | tr -d '"')"
        if [ "${fp:-}" ]; then
            allImages+=( "${image%:*}:${fp}" )
            docker tag "$image" "${image%:*}:${fp}"  > /dev/null 2>&1 || : # ignore any errors
        fi
    done
    mapfile -t allImages < <(printf '%s\n' "${allImages[@]}" | uniq)

    local attempt
    for image in "${allImages[@]}"; do
        for attempt in {0..2}; do
            echo -e "    \e[94mPushing ${image}\e[0m"
            docker push "$image" && break
            [ $attempt -eq 2 ] && trap.die "Failed to push $image"
            echo 'retrying...'
        done
    done

    for image in "${allImages[@]}"; do
        local -i wasTagged=0
        for inp in "${images[@]}"; do
            if [ "$inp" = "$image" ]; then
                wasTagged=1
                break
            fi
        done
        [ "$wasTagged" -eq 1 ] || docker rmi "$image"
    done
}
export -f registry.push

#----------------------------------------------------------------------------------------------
function registry.rename()
{
    local src=${1:?}
    local dst=${2:?}

    # strip name of server
    src=${src#$(registry.SERVER)}
    dst=${dst#$(registry.SERVER)}

    local srcName="${src%:*}"
    local srcTag="${src##*:}"
    [ "${srcName:-}" ] && [ "${srcTag:-}" ] || trap.die "Invalid $src specified"

    local dstName="${dst%:*}"
    local dstTag="${dst##*:}"

    [ "${dstTag:-}" ] || dstTag="$srcTag"
    [ "${dstName:-}" ] && [ "$dstName" != "$dstTag" ] || $dstName="$srcName"
    [ "$srcName" != "$dstName" ] || [ "$srcTag" != "$dstTag" ] || trap.die "$src & $dst specify same image"

    local exists=$(docker image ls --quiet "$(registry.SERVER)$src")
    [ "${exists:-}" ] || docker pull "$(registry.SERVER)$src"
    docker tag "$(registry.SERVER)$src" "$(registry.SERVER)${dstName}:$dstTag"
    registry.push "$(registry.SERVER)${dstName}:$dstTag"
    [ "${exists:-}" ] || docker rmi "$(registry.SERVER)$src"
    registry.deleteImage "$(registry.SERVER)$src"
}
export -f registry.rename

#----------------------------------------------------------------------------------------------
function registry.reportCatalog()
{
    local -a catalog=( "$@" )
    [ ${#catalog[*]} -eq 0 ] && mapfile -t catalog < <(registry.catalog)

    local -A tags
    local -i index=0
    local -r ref='latest'
    for entry in "${catalog[@]}"; do
        (( index++ )) || true
        eval tags=( $(registry.tags "$entry") )
        printf '%05d,%d,%s:\n' $index ${#tags[*]} $entry

        local latest="${tags[$ref]:-}"
        (for tag in "${!tags[@]}"; do
             [ "${latest:-}" ] && [ "$tag" = "$ref" ] && [ ${#tags[@]} -gt 1 ] && continue
             printf '       %s %s' "$(registry.createTime "$entry" "$tag")" "$tag"
             [ "${latest:-}" ] && [ "$latest" = "${tags[$tag]}" ] && [ ${#tags[@]} -gt 1 ] && echo -n " $ref"
             echo
         done) | sort
    done
}
export -f registry.reportCatalog

#----------------------------------------------------------------------------------------------
function registry.tags()
{
    local -r name=${1:?}

    local -a tags=()
    local -r manifest=$(registry.GET --silent "$(registry.URL)/${name}/tags/list")

    [ -z "${manifest:-}" ] || mapfile -t tags < <(jq '.tags[]?' <<< "$manifest" | tr -d '"')
    for tag in "${tags[@]}"; do
        printf "['%s']='%s'\n" "$tag" "$(registry.digest "$name" "$tag")"
    done
}
export -f registry.tags
