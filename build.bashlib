#!/bin/bash

declare DOCKER_REGISTRY=ubuntu-s2:5000/
declare REGISTRY_URL=http://${DOCKER_REGISTRY}v2
declare -ra YAML_TO_JSON=( 'python' '-c' 'import sys, yaml, json; json.dump(yaml.load(sys.stdin), sys.stdout, indent=4)' )

##############################################################################################
function die()
{
    echo "***ERROR: $1" >&2
    exit 1
}

##############################################################################################
function build.allContainers()
{
    local -a modules=( "$@" )

    # Use the Unofficial Bash Strict Mode
    set -o errexit
    set -o nounset
    set -o pipefail
    IFS=$'\n\t'

    set +o verbose
    set +o xtrace

    local start=$(date +%s)
    [ -f ~/bin/trap.bashlib ] && source ~/bin/trap.bashlib

    export CFG_GITHUB_EMAIL=''
    export CFG_GITHUB_HUBOT_TOKEN=''
    export CFG_GITHUB_JENKINS_EMAIL=''
    export CFG_GITHUB_JENKINS_NAME=''
    export CFG_GITHUB_JENKINS_TOKEN=''
    export CFG_GITHUB_JENKINS_USER=''
    export CFG_GITHUB_NAME=''
    export CFG_GITHUB_TOKEN=''
    export CFG_GITHUB_USER=''
    export CFG_PASS=''
    export CFG_SLACK_HUBOT_TOKEN=''
    export CFG_USER=''
    export BASE_TAG=${BASE_TAG:-latest}
    export DOCKER_REGISTRY

    for dir in "${modules[@]}"; do
        if [ -d "$dir" ]; then
             pushd "$dir" >/dev/null
            [ "$dir" = base_container ] || unset CBF_VERSION
            build.updateContainer
            popd >/dev/null
        else
            echo "invalid project directoryt: $dir"
        fi
    done

    local finish=$(date +%s)
    local -i elapsed=$(( finish - start ))

    echo
    echo
    TZ='America/New_York' date
    printf "Time elapsed: %02d:%02d:%02d\n"  $((elapsed / 3600)) $((elapsed % 3600 / 60)) $((elapsed % 60))
}

##############################################################################################
function build.calculateFingerprint()
{
    local -r config=${1:?}

    # get the following
    #  - git tree hash
    #  - resolved 'docker build.args' config from docker-compose.yml
    #  - container digest of layer that we are building on top of
    #  - anything dirty in workspace


    # git tree hash
    local -a dependents
    mapfile -t dependents < <(git ls-tree HEAD -- . | awk '{print $3}')

    # resolved 'docker build.args' config from docker-compose.yml
    set +u
    dependents+=( "$(eval echo $(jq '.build.args?' <<< "$config"))"
                  "${CBF_VERSION:-}"
                )
    set -u
    
    # add any local 'build/container_build_framework' folder
    local -a files
    set +o pipefail
    mapfile -t files < <(find build/container_build_framework* -type f -name '*' 2>/dev/null | true)
    set -o pipefail
    for file in "${files[@]}"; do
        dependents+=( "$(sha256sum "$file")" )
    done

    # container digest of layer that we are building on top of
    local base=$(eval echo $( jq '.build.args.FROM_BASE' <<< "$config" ))
    if [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$base")" ]; then
        echo pulling parent image: "$base" >&2
        docker pull "$base" >&2 || return 0
    fi
    dependents+=( $(docker inspect "$base" | jq '.[].Id' ) )

    # anything dirty in workspace
    for line in $(git status --porcelain); do
        local file=$(awk '{print $2}' <<< "$line")
        case $(awk '{print $1}' <<< "$line") in
            A|M|MM)
                dependents+=( "$(sha256sum "$file")" );;
            *)
                dependents+=( "$line" );;
        esac
    done

    # generate fingerprint from all our dependents
    (sha256sum | cut -d' ' -f1) <<< "${dependents[*]}"
}

##############################################################################################
function build.changeImage()
{
    local taggedImage=${1:?}
    local actualImage=${2:?}

    [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}'  --filter "reference=$taggedImage")" ] || \
        [ "$(docker ps --format '{{.Image}}' | grep "$taggedImage")" ] || \
        docker rmi "$taggedImage"

    [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$actualImage")" ] || \
        docker tag "$actualImage" "$taggedImage"
}

##############################################################################################
function build.dockerCompose()
{
    local jsonConfig=$( "${YAML_TO_JSON[@]}" < docker-compose.yml | jq '.services?')
    if [ "${jsonConfig:-}" ]; then
        local -r service="$(eval echo $(jq 'keys[0]?' <<< "$jsonConfig"))"
        [ -z "${service:-}" ] || jq $(eval echo "'.\"$service\"?'") <<< "$jsonConfig"
    fi
}

##############################################################################################
function build.findIdsWithFingerprint()
{
    local -r fingerprint=${1:?}

    local -a ids
    mapfile -t ids < <(curl --silent \
                            --unix-socket /var/run/docker.sock http://localhost/images/json \
                       | jq ".[]|select(.Labels.\"container.fingerprint\" == \"$fingerprint\").Id")
    for id in "${ids[@]}"; do
        eval echo $id
    done
}

##############################################################################################
function build.push()
{
    local -ra images=( "$@" )
    
    local -a allImages=()
    for image in "${images[@]}"; do
        allImages+=( "$image" )
        local fp="$( eval echo $(docker inspect "$image" | jq '.[].Config.Labels."container.fingerprint"?') )"
        [ -z "${fp:-}" ] || allImages+=( "${image%:*}:${fp}" )
    done
    mapfile -t allImages < <(printf "%s\n" "${allImages[@]}" | uniq)

    local attempts
    for image in "${allImages[@]}"; do
        for attempt in {0..2}; do
            echo -e "    \e[94mPushing ${image}\e[0m\n"
            docker push "$image" && break
            [ $attempt -eq 2 ] && die "Failed to push $image"
            echo 'retrying...'
        done
    done
}

##############################################################################################
function build.updateContainer()
{
    local config=$(build.dockerCompose)

    local taggedImage="$(eval echo $(jq '.image?' <<< $config))"
    taggedImage="${taggedImage%:*}:${BASE_TAG}"

    local -r fingerprint="$(build.calculateFingerprint "$config")"
    [ "${fingerprint:-}" ] || die "No base image found for $taggedImage: unable to calulate fingerprint."

    if [ -z "${ALWAYS_BUILD:-}" ]; then
        # check if there is a local image with the correct fingerprint
        local -a images
        mapfile -t images < <(build.findIdsWithFingerprint "$fingerprint")
        if [ ${#images[*]} -gt 0 ]; then
            echo "${taggedImage} has not changed."
            return 0
        fi
    fi

    # get image tagged with fingerprint
    export CONTAINER_TAG="$fingerprint"
    local actualImage="$(eval echo $(jq '.image?' <<< $config))"


    echo "building $actualImage"
    # check if there is an image in the registry with the correct fingerprint
    if [ -z "${ALWAYS_BUILD:-}" ] && docker pull "$actualImage" 2>/dev/null; then
        # downloaded image from registry
        build.changeImage "$taggedImage" "$actualImage"
        docker rmi "$actualImage"
        return 0
    fi
    
    local -r revision="$(git describe --tags --dirty)"

    # setup environment for 'docker-compose build'
    export CONTAINER_BUILD_TIME=$(date +%Y%m%d-%H%M%S.%N -u)
    export CONTAINER_FINGERPRINT="${CONTAINER_TAG:-}"
    export CONTAINER_GIT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
    export CONTAINER_GIT_COMMIT="$(git rev-parse HEAD)"
    export CONTAINER_GIT_URL="$(git remote get-url origin)"
    export CONTAINER_ORIGIN="$revision"

    # rebuild container because no container exists with the correct fingerprint
    docker-compose build  ||  die "Build failure"

    build.changeImage "$taggedImage" "$actualImage"
    [ -z "$(docker images --format '{{.Repository}}:{{.Tag}}' --filter "reference=$taggedImage")" ] && docker tag "$actualImage" "$taggedImage"

    if registry.canPush "$revision"; then
        build.push "$taggedImage"
    fi
    docker rmi "$actualImage"
    return 0
}

##############################################################################################
function build.yamlToJson()
{
    local -r yamlFile=${1:?}
    if [ -e $yamlFile  ]; then
        "${YAML_TO_JSON[@]}" < $yamlFile

    elif [[ $yamlFile == http* ]]; then
        "${YAML_TO_JSON[@]}" <<< $(curl --insecure --silent --request GET  "$yamlFile")

    else
        "${YAML_TO_JSON[@]}" <<< "$yamlFile"
    fi
}

##############################################################################################
function registry.canPush()
{
    local -r revision=${1:?}

    [ "${DOCKER_ALWAYS_PUSH:-}" ] && return 0
    [[ "$revision" != *dirty ]] || return 1

#    [ "$CONTAINER_GIT_BRANCH" = 'master' ]

    return 0
}

##############################################################################################
function registry.deleteImage()
{
    local -r id=${1:?}

    local -r name="${id%:*}"
    local -r tag="${id##*:}" 
    [ "${name:-}" ] && [ "${tag:-}" ] || die "Invalid $id specified" 

    local -r digest="$(registry.getDigest "$name" "$tag")"
    curl --insecure --verbose --request DELETE "${REGISTRY_URL}/${name}/manifests/${digest}"
}

##############################################################################################
function registry.getCatalog()
{
    local -a entries=()
    local -r catalog=$(curl --insecure --silent --request GET "${REGISTRY_URL}/_catalog")
    [ -z "${catalog:-}" ] || [[ "$catalog" =~ *error* ]] ||  mapfile -t entries < <(jq '.repositories[]' <<< "$catalog")
    for entry in "${entries[@]}"; do
        eval echo $entry
    done
}

##############################################################################################
function registry.getCreateTime()
{
    local -r name=${1:?}
    local -r tag=${2:?}

    local -r manifests="$(registry.getManifest "$name" "$tag" )"
    if [ -z "$manifests" ] || [[ $manifests =~ MANIFEST_INVALID ]]; then
        echo '                      '
    else
        (jq '[ .history[].v1Compatibility|fromjson.created | sub("\\.\\d+Z"; "Z") | fromdate] | max | todate' ) <<< "$manifests"
    fi
}

##############################################################################################
function registry.getDigest()
{
    local -r name=${1:?}
    local -r tag=${2:?}

    local -r digest="$(curl --header "Accept: application/vnd.docker.distribution.manifest.v2+json" \
                            --insecure \
                            --silent \
                            --head \
                            --request GET "${REGISTRY_URL}/${name}/manifests/${tag}" )"

    ( awk '{gsub(/\r/,"");if ($1 == "Docker-Content-Digest:") {print $2}}') <<< "$digest"
}

##############################################################################################
function registry.getLayer()
{
    local -r name=${1:?}
    local -r digest=${2:?}

    curl --insecure --silent --request GET "${REGISTRY_URL}/${name}/blobs/${digest}"
}

##############################################################################################
function registry.getManifest()
{
    local -r name=${1:?}
    local -r reference=${2:?}

    curl --insecure --silent --request GET "${REGISTRY_URL}/${name}/manifests/${reference}"
}

##############################################################################################
function registry.getTags()
{
    local -r name=${1:?}

    local -a tags=()
    local -r manifest=$(curl --insecure --silent --request GET "${REGISTRY_URL}/${name}/tags/list")
    [ -z "${manifest:-}" ] || [[ "$manifest" =~ MANIFEST_INVALID ]] || mapfile -t tags < <(jq '.tags[]?' <<< "$manifest")
    for tag in "${tags[@]}"; do
        tag=$(eval echo $tag)
        printf "['%s']='%s'\n" "$tag" "$(registry.getDigest "$name" "$tag")"
    done
}

##############################################################################################
function registry.reportCatalog()
{
    local -a catalog=( "$@" )
    [ ${#catalog[*]} -eq 0 ] && mapfile -t catalog < <(registry.getCatalog)

    local -A tags
    local -i index=0
    local -r ref='latest'
    for entry in $(printf "%s\n" "${catalog[@]}" | sort);do
        (( index++ )) || true
        eval tags=( $(registry.getTags "$entry") )
        printf "%05d,%d,%s:\n" $index ${#tags[*]} $entry

        local latest="${tags[$ref]:-}"
        (for tag in "${!tags[@]}"; do
             [ "${latest:-}" ] && [ "$tag" = "$ref" ] && [ ${#tags[@]} -gt 1 ] && continue
             printf "       %s %s" "$(registry.getCreateTime "$entry" "$tag")" "$tag"
             [ "${latest:-}" ] && [ "$latest" = "${tags[$tag]}" ] && [ ${#tags[@]} -gt 1 ] && printf " $ref"
             echo
         done) | sort
    done
}
